<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/03/17/BUAA-OO-Unit1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="BUAA-OO-第一单元表达式展开"><a href="#BUAA-OO-第一单元表达式展开" class="headerlink" title="BUAA-OO 第一单元表达式展开"></a>BUAA-OO 第一单元表达式展开</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一单元主要通过对表达式结构进行建模，完成多变量多项式的括号展开，初步体会层次化设计思想。主要考察了Java基础语法和<strong>基本容器</strong>的使用，扩展BNF描述的形式化表述和<strong>正则表达式</strong>、<strong>递归下降</strong>等方法的使用。</p>
<p>本单元一共有三次作业，第一次作业是多变量表达式的展开化简，第二次作业加入三角函数和自定义函数的形式，第三次作业加入求导因子dx，dy，dz，又新增了求导功能。这三次作业难度是层层递进的，经过近一个月，第一单元的学习终于临近结束，在本篇博客里，我将详细分析这三次作业的框架结构和注意事项，并分享我学习第一单元的心得体会。</p>
<h2 id="基于度量来分析自己的程序结构"><a href="#基于度量来分析自己的程序结构" class="headerlink" title="基于度量来分析自己的程序结构"></a>基于度量来分析自己的程序结构</h2><h3 id="度量分析"><a href="#度量分析" class="headerlink" title="度量分析"></a>度量分析</h3><ul>
<li><strong>度量类的属性个数、方法个数、每个方法规模、每个方法的控制分支数目、类总代码规模</strong>，<strong>计算经典的OO度量</strong></li>
</ul>
<p>首先看下图的复杂度分析，<code>MyComparator</code>类、<code>Parser</code>类和<code>Definer</code>类的复杂度都很高</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/%E7%B1%BB%E7%9A%84OO%E5%BA%A6%E9%87%8F.png" alt="类的OO度量"></p>
<p>下面贴上<code>Parser</code>类方法的复杂度图</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/Parser%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%A6%E9%87%8F.png" alt="Parser内部方法的度量"></p>
<p>可以发现<code>parseFactor()</code>方法除了基本复杂度，其他指标都很高，它负责的工作很多，写的时候思路并没有那么清晰，需要结合注释理解才能看懂，增加了debug工作的难度。</p>
<h3 id="代码的UML类图"><a href="#代码的UML类图" class="headerlink" title="代码的UML类图"></a>代码的UML类图</h3><p>第一单元作业代码的<code>UML</code>类图如下所示</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/test.png" alt="UML1"></p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/Unit1UML.png" alt="test"></p>
<p><strong>分析类的内聚和相互间的耦合情况以及优缺点</strong></p>
<ul>
<li><p>各个类的设计考虑：</p>
<ul>
<li><p><code>Main</code>：主类，程序的主要流程</p>
</li>
<li><p><code>Definer</code>：解析自定义函数类，用于存储自定义函数定义、解析表达式中出现的自定义函数</p>
</li>
<li><p><code>Derivation</code>：求导因子类，用于存储表达式中出现的求导算子和被求导表达式</p>
</li>
<li><p><code>Expression</code>：表达式类，用于存储表达式或表达式因子</p>
</li>
<li><p><code>Factor</code>：因子类，用于存储因子类型和因子</p>
</li>
<li><p><code>FunFactor</code>：自定义函数因子类，用于存储自定义函数因子</p>
</li>
<li><p><code>Function</code>：幂函数因子类</p>
</li>
<li><p><code>Item</code>：单项式类</p>
</li>
<li><p><code>Lexer</code>：词法解析器</p>
</li>
<li><p><code>Multinomial</code>：多项式类</p>
</li>
<li><p><code>MyCompartor</code>：用于排序</p>
</li>
<li><p><code>Parser</code>：语法分析器</p>
</li>
<li><p><code>Process</code>：用于初步处理表达式，去除空白字符和化简加减号</p>
</li>
<li><p><code>Term</code>：项类</p>
</li>
<li><p><code>Token</code>：用于存储表达式中每类字符及其类型</p>
</li>
<li><p><code>TriangleFactor</code>：三角函数因子类</p>
</li>
</ul>
</li>
<li><p>设计缺点：</p>
<ul>
<li>应该将<code>Factor</code>设为接口，每次用type判断因子类型很麻烦，而且存储空间利用率小</li>
<li><code>MyComparator</code>类可以省去，因为按照x y z的指数排序其实并不重要</li>
<li><code>Lexer</code>类用正则表达式解析词法过于繁琐，用多重if-else判断增加复杂度</li>
<li><code>Process</code>类多余，直接化简即可</li>
<li>利用多项式单项式进行求导很繁琐，应该改为利用因子、项和表达式的特点进行层次化求导</li>
</ul>
</li>
<li><p>设计优点</p>
<ul>
<li>递归下降的使用</li>
<li>利用单项式多项式的结构处理表达式较为清晰，且很多方法可以复用如多项式的加法和乘法</li>
</ul>
</li>
</ul>
<h2 id="第一次作业分析"><a href="#第一次作业分析" class="headerlink" title="第一次作业分析"></a>第一次作业分析</h2><p>第一次作业的任务：读入一个包含加、减、乘、乘方以及括号的多变量表达式，输出恒等变形展开所有括号后的表达式。</p>
<p>其中，表达式由多个项加减而成，每个项由多个因子相乘得到。本次作业中因子包括变量因子（幂函数）、常数因子（带符号整数）、表达式因子（’(‘表达式’)’ [空白项 指数])</p>
<h3 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h3><p>分别建立<code>Expression</code>类、<code>Term</code>类、各种<code>Factor</code>类来存储表达式中各个元素。其中<code>Expression</code>类中用两个<code>Arraylist</code>分别存储<code>Term</code>和每个<code>Term</code>前的符号，<code>Term</code>类中用<code>Arraylist</code>存储每个<code>Factor</code>。</p>
<h4 id="递归下降解析表达式"><a href="#递归下降解析表达式" class="headerlink" title="递归下降解析表达式"></a>递归下降解析表达式</h4><p>首先用正则表达式构建<code>Lexer</code>类，即将表达式拆分成一个个字符类型。例如：<code>（x**2+y)*3</code>，解析得出<code>tokens</code>即为<code>(,x,**,2,+,y,),*,3</code></p>
<p><strong><code>Lexer</code>部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;	</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNKNOWN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(x|y|z)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXPONENTSIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\*\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="string">&quot;^\\s*([\\+\\-]?[0-9]+)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\+|\\-|\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEFT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\()&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\))&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FUNC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;f|g|h)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DOC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(,)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SINCOS</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(sin|cos)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DERIVATIVE</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(dx|dy|dz)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Lexer</span><span class="params">(String temp)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.position = <span class="number">0</span>;</span><br><span class="line">   		<span class="type">int</span> <span class="variable">des</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示可把符号作为第一项符号</span></span><br><span class="line">     	<span class="keyword">while</span> (des &lt; temp.length()) &#123;</span><br><span class="line">            <span class="comment">//正则匹配各个Token</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">back</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><code>Parser</code>类中包含上文解析所得的一个<code>Lexer</code>，然后就是各种解析方法，包括<code>parseFactor()</code>，<code>parseTerm()</code>，<code>parseExpr()</code>等。</p>
<p><strong>Parser部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Lexer lexer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLexer</span><span class="params">(Lexer lexer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lexer = lexer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">parseFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseFactor解析并返回Factor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Term <span class="title function_">parseTerm</span><span class="params">()</span> &#123;</span><br><span class="line">     	<span class="comment">//parseTerm解析并返回Term</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Expression <span class="title function_">parseExp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseExpr解析返回Expression</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> Function <span class="title function_">parsePowerFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parsePowerFunction解析并返回Function(幂函数因子)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="表达式展开"><a href="#表达式展开" class="headerlink" title="表达式展开"></a>表达式展开</h4><p>新建立两个类<code>Item</code>和<code>Multinomial</code>分别处理<strong>表达式展开后</strong>的单项式和多项式。</p>
<p><code>Item</code>类中含有系数<code>number</code>，x y z的指数<code>ex</code>、<code>ey</code>、<code>ez</code>，还有方法<code>toString()</code>将<strong>单项式转为字符串</strong>便于输出。</p>
<p><code>Multinomial</code>类中含有<code>Hashset</code>用于存储<code>Item</code>集合，以及方法<code>toString()</code>，还包括了<code>addFor()</code>,<code>mulFor()</code>,<code>powFor()</code>,<code>simplify()</code>分别进行多项式加法、乘法、乘方和<strong>多项式简化</strong>。</p>
<p><strong>powFor()的部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Multinomial <span class="title function_">powFor</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">       <span class="type">Multinomial</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();</span><br><span class="line">       <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">           result.items.add(item);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; temp;i++) &#123;</span><br><span class="line">           result = result.mulFor(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       result.simplify();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ul>
<li>在预处理表达式时，除了处理多个符号，还要记得去除所有<strong>空格</strong>和<strong>\t</strong> (第二次作业bug就出在这里o(╥﹏╥)o。</li>
<li>解析<code>parser</code>时一定要注意<code>lexer</code>的位置，多想几遍有没有多向前一步或者少向前一步，这个地方极易出bug</li>
<li>解析表达式因子时记得括号外面可能还会有指数！</li>
<li>优化时，记得判断最终结果是不是为空，为空就输出0</li>
</ul>
<h3 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第一次作业暂时未发现bug(事实证明只是没发现，并不是没有)</p>
<h2 id="第二次作业分析"><a href="#第二次作业分析" class="headerlink" title="第二次作业分析"></a>第二次作业分析</h2><p>第二次作业在第一次作业的基础上增加了一系列<strong>自定义函数</strong>和<strong>三角函数因子</strong></p>
<ul>
<li><p><em>三角函数因子</em>：类似于幂函数，由<code>sin(&lt;因子&gt;)</code>或<code>cos(&lt;因子&gt;)</code> 、指数符号<code>**</code>和指数组成</p>
</li>
<li><ul>
<li><p>自定义函数的定义：形如 <code>f(x, y, z) = 函数表达式</code> ，比如 <code>f(y) = y**2</code>  </p>
</li>
<li><p>自定义函数的<strong>调用</strong>形如 <code>f(因子, 因子, 因子)</code></p>
</li>
<li><p><code>x</code>、<code>y</code>、<code>z</code> 为函数的<strong>形参</strong>。在本次作业中，<strong>形参个数为 1~3 个</strong>。形参**只使用 <code>x</code>，<code>y</code>，<code>z</code>**，且同一函数定义中不会出现重复使用的形参</p>
</li>
<li><p><code>f</code> 、<code>g</code>、<code>h</code> 是函数的<strong>函数名</strong>。在本次作业中，保证函数名<strong>只使用 <code>f</code> ，<code>g</code>，<code>h</code><strong>，且</strong>不出现同名函数的重复定义</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义函数的解析"><a href="#自定义函数的解析" class="headerlink" title="自定义函数的解析"></a>自定义函数的解析</h3><p>对于自定义函数，新增了<code>FuncFactor</code>和<code>Definer</code>两个类，分别用来<strong>存储</strong>和<strong>解析</strong>自定义函数。对于<code>Lexer</code>和<code>Parser</code>类中也进行了改动。</p>
<ul>
<li><p><strong>Definer</strong></p>
<p><code>Definer</code>类中包含两个<code>Hashmap</code>，第一个<code>parameters</code>键值对为<code>&lt;String,Arraylist&lt;String&gt;&gt;</code>，用来存储函数名和形参集合映射；第二个<code>functions</code>键值对为<code>&lt;String,String&gt;</code>，用来存储函数名和函数定义式映射。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;String,ArrayList&lt;String&gt;&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，形参集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> HashMap&lt;String,String&gt; functions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，定义式</span></span><br></pre></td></tr></table></figure></div>



<p><code>Definer</code>类中还包括<code>addFunc()</code>和<code>callFunc()</code>两个方法，分别用来<strong>存储函数形参</strong>、<strong>定义式</strong>和处理表达式中的自定义函数。</p>
<p>对于开始输入自定义函数及其定义时，用<code>addFunc()</code>方法解析并存储对应函数名的定义式中各形参集合，存储并化简函数的定义式。</p>
<p>在处理完所有自定义函数后，解析表达式时若遇到自定义函数，则用<code>callFunc()</code>方法处理该部分。解析出表达式自定义函数中的实参，通过函数名，得到对应定义式和形参集合，将定义式中的<strong>形参替换为实参</strong>，再对替换完的字符串进行解析，得到最终表达式。</p>
<blockquote>
<p>注意：在用<code>replaceAll()</code>替换形参时，若有多个形参，可能会造成替换错误。所以，可以在存储函数自定义函数的定义式和形参时用u,v,w代替x,y,z,以免出错。</p>
</blockquote>
</li>
<li><p><strong>FuncFactor</strong></p>
<p><code>FuncFactor</code>类中包含一个<code>String</code>类型的<code>updateFunc</code>，表示将形参替换为实参后的字符串，还有一个<code>Expression</code>类型的<code>expression</code>，存储将前者字符串解析后的表达式。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncFactor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String updateFunc;<span class="comment">//实参带入后的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Expression expression;<span class="comment">//解析成表达式</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="三角函数的解析"><a href="#三角函数的解析" class="headerlink" title="三角函数的解析"></a>三角函数的解析</h3><p>对于三角函数，增加了<code>TriangleFactor</code>类用于存储三角函数；</p>
<p>在解析表达式方面对于<code>Lexer</code>类和<code>Parser</code>类进行了改动；</p>
<p>在表达式展开方面，对于Item类新增了两个<code>HashMap</code>，键值对均为&lt;<code>Multinomial</code>,<code>int</code>&gt;，分别用来存储sin集合和cos集合，其<code>toString()</code>方法也要进行修改。（PS：以sin为例，<code>Multinomial</code>为sin内部多项式，<code>int</code>为sin的指数）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">//单项式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ez;<span class="comment">//表示x，y，z的指数</span></span><br><span class="line">    <span class="keyword">private</span> BigInteger number;</span><br><span class="line">    <span class="comment">//sin()里多项式，三角函数指数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; sinUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; cosUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>对于<code>Multinominal</code>类对于加法、乘法、化简等方法做一些改动。</p>
<blockquote>
<p><strong>ATTENTION！！！</strong></p>
<ul>
<li>在实现<code>Multinominal</code>对象的运算时，对任何类最好都进行<strong>深克隆</strong>（浅克隆容易出bug）</li>
</ul>
<p>因为浅克隆只是复制了该对象的引用，当改变对象中变量的值时，被克隆对象的相应值也发生改变</p>
<ul>
<li>在对Multinomial进行合并同类项化简时，注意如果这个Multinomial中所有Item全部消除为0时（此时items为空），多加一个number为0的Item对象进Multinomial，表示此时多项式为0，防止运算时出现错误</li>
</ul>
</blockquote>
<p>对于<code>TriangleFactor</code>类，其中包含<code>String</code>类型的<code>type</code>，<code>Factor</code>类型的<code>factor</code>，<code>int</code>类型的<code>exp</code>，分别用来记录当前因子是sin|cos，存储三角函数内部因子和记录三角函数的指数。</p>
<blockquote>
<p>sin(0) &#x3D; 0</p>
<p>cos(0) &#x3D; 1</p>
</blockquote>
<p>为了便于三角函数的进一步化简即合并同类项，我在这里对<code>Multinominal</code>和<code>Item</code>类的<code>hashcode</code>和<code>equals</code>方法进行<strong>重写</strong>，重写代码如下：</p>
<p><strong>Item</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> (Item) o;</span><br><span class="line">		<span class="keyword">return</span> ex == item.ex &amp;&amp; ey == item.ey &amp;&amp; ez == item.ez 				&amp;&amp;Objects.equals(number, item.number)&amp;&amp; 					Objects.equals(sinUnit, item.sinUnit) &amp;&amp; 					Objects.equals(cosUnit, item.cosUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(ex, ey, ez, number, sinUnit, cosUnit);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>Multinomial</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Multinomial</span> <span class="variable">that</span> <span class="operator">=</span> (Multinomial) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(items, that.items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意，在重写了<code>hashcode</code>和<code>equals</code>方法后，在<code>Hashmap</code>和<code>Hashset</code>中用<code>Item</code>或<code>Multinomial</code>作为键时，添加元素时要<strong>提前判断该键是否已存在</strong>集合里，若已存在，对已有元素的int值进行累加，反之直接add。（若不加判断直接add，原数据会被覆盖）</p>
</blockquote>
<h3 id="BUG分析-1"><a href="#BUG分析-1" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第二次作业的强测很惨很惨，这也让我发现了第一次作业没发现的bug</p>
<ul>
<li>在中测时，发现了<code>Multinomial</code>类中表达式进行乘法、加法时出现的浅克隆的bug，这种情况我最后都修改成了深克隆，bug就修复完成了</li>
<li>在初步处理表达式时，没有把<code>\t</code>去除。我仅仅用了<code>replaceAll(&quot; &quot;,&quot;&quot;)</code>去除了所有空格，而忘记了<code>\t</code>也是题目中提到的空白字符www</li>
<li>最后，强测中发现我的sin(0)在<code>Item</code>类的<code>toString()</code>中转为字符串是”1”,但是应该是”0”啊啊啊啊啊</li>
</ul>
<h2 id="第三次作业解析"><a href="#第三次作业解析" class="headerlink" title="第三次作业解析"></a>第三次作业解析</h2><p>第三次作业在第二次作业的基础上，新增了<strong>求导算子</strong>的概念，作业要求仍是对表达式进行展开和化简，但是最终结果不能包括括号和求导算子。</p>
<ul>
<li><p><em>求导因子</em></p>
<ul>
<li>求导因子可以出现在很多位置，包括<strong>函数调用实参</strong>，<strong>函数定义表达式</strong>，<strong>三角函数内部</strong>。</li>
<li>由<code>dx(表达式)</code>,<code>dy(表达式)</code>,<code>dz(表达式)</code>三种算符构成，分别代表对表达式的x变量求导，对表达式的y变量求导，对表达式的z变量求导。</li>
<li>由于本单元表达式自变量有三个分别为x,y,z，因此<strong>这里的求导可以理解为偏导</strong>。</li>
<li>为了保证<strong>结果一致性</strong>，自定义函数内包含求导因子，当调用该函数时，先将自定义函数表达式求导后再代入实参。例如函数<code>h(x) = dx(x)</code>,自定义函数调用<code>h(sin(x)) = 1</code>而不是<code>h(sin(x))=cos(x)</code>。</li>
</ul>
</li>
<li><p><em>求导公式</em></p>
<p>本次作业可能用到的<strong>求导公式</strong>有：<br>$$<br>Ⅰ.当f(x)&#x3D;c（c为常数）时，f’(x)&#x3D;0<br>$$</p>
<p>$$<br>Ⅱ.当f(x)&#x3D;x^n （n&#x3D;0）时。f’(x)&#x3D;n \ast x ^ {n-1}<br>$$</p>
<p>$$<br>Ⅲ.当f(x)&#x3D;sin(x)时，f’(x)&#x3D;cos(x)<br>$$</p>
<p>$$<br>Ⅳ.当f(x)&#x3D;cos(x)时，f’(x)&#x3D;−sin(x)<br>$$</p>
<p>$$<br>Ⅴ.链式法则：[f(g(x))]’&#x3D;f’(g(x))g’(x)<br>$$</p>
<p>$$<br>Ⅵ.乘法法则：[f(x)g(x)]’&#x3D;f’(x)g(x)+f(x)g’(x)<br>$$</p>
</li>
</ul>
<h3 id="求导算子的实现"><a href="#求导算子的实现" class="headerlink" title="求导算子的实现"></a>求导算子的实现</h3><h4 id="求导因子的解析"><a href="#求导因子的解析" class="headerlink" title="求导因子的解析"></a>求导因子的解析</h4><p>本次作业新增了<code>Derivation</code>类，用于存储求导因子。修改了<code>Lexer</code>和<code>Parser</code>类，新增了求导因子的解析方法，和前几种因子写法类似。</p>
<p>Derivation类的部分代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derivation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//x|y|z</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Factor</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factor</span>();<span class="comment">//表达式因子(expr)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Multinomial</span> <span class="variable">processed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();<span class="comment">//已求导多项式</span></span><br><span class="line"> 	</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="求导方法的实现"><a href="#求导方法的实现" class="headerlink" title="求导方法的实现"></a>求导方法的实现</h4><p>由于所有因子、项、表达式最终都可转换为<strong>多项式</strong>，并且对多项式求导只需逐个对多项式中<strong>单项式求导</strong>，所得的求导结果相加即可求得最终结果，所以本文采用对多项式和单项式求导的方法解决对求导因子的化简。</p>
<p>因为Item的存储形式为 <code>number * x**ex * y**ey * z**ez * sinUnits * cosUnits </code>  ,根据求导公式的特点可将每个Item对象分为三部分 ：</p>
<ul>
<li>section 1：<code>( number * x**ex * y**ey * z**ez )</code></li>
<li>section 2：<code>(sinUnits)</code></li>
<li>section 3：<code>(cosUnits)</code></li>
</ul>
<p>整个Item即为这三部分相乘，那么根据乘法法则，单项式求导结果即为：</p>
<p>(1)’ * (2) * (3) + (2)’ * (1) * (3) + (3)’ * (1) * (2)</p>
<blockquote>
<p>(1)代表section 1 ，(2) 代表section 2 ，(3)代表section 3</p>
</blockquote>
<ol>
<li><p>对于<strong>section 1</strong> 的求导根据求导公式一次即可求出。</p>
</li>
<li><p>对于<strong>section 2</strong> 的求导：</p>
</li>
</ol>
<p>​	对于sin集合，遍历<code>Hashmap</code>，对于每次取得的**&lt;Multinomial,int&gt;** ,根据链式法则</p>
<ul>
<li>先判断int是否大于0，若等于0直接得出求导结果为0，若大于0则得出第一部分求导结果为exp * sin(Multinomial)**(exp -1)</li>
<li>再对sin本身求导，根据三角函数求导公式可得第二部分求导结果为cos(Multinomial)</li>
<li>再对Multinomial求导，用多项式求导方法返回求导结果</li>
<li>section 2求导结果即为这三部分相乘</li>
</ul>
<p>​	最终求导结果为<code>HashMap</code>中每个元素的求导结果乘其他各个元素，再一起相加。</p>
<ol start="3">
<li>对于<strong>section 3</strong> 的求导和section 2 部分类似，注意d(cos(x)) &#x3D; -sin(x)</li>
</ol>
<blockquote>
<p>ATTENTION</p>
<p>求导运算时也要时刻注意运用<strong>深克隆</strong>！！！</p>
</blockquote>
<h3 id="BUG分析-2"><a href="#BUG分析-2" class="headerlink" title="BUG分析"></a>BUG分析</h3><ul>
<li><p>这次作业主要发现的bug就是，用<code>Hashset</code>存储<code>Item</code>时，应当<strong>判断容器中是不是有相同key存在</strong></p>
<p>我一开始写法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前操作想要把item放入items中，如果有相同key，就删除原有key，再把item的系数加倍，放入items</span></span><br><span class="line"><span class="keyword">if</span> (items.contain(item)) &#123;</span><br><span class="line">	items.remove(item);</span><br><span class="line">	items.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>是不是看起来很合理！！！其实并不……因为我没有考虑到<strong>item系数加倍后的新item</strong>，在items容器中有没有<strong>重复的key</strong>！！！</p>
<p>最终我的修改如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(items.contains(item)) &#123;</span><br><span class="line"> 		result.deleteItem(item);<span class="comment">//删去原有item</span></span><br><span class="line">        item.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line">items.setItems(item);</span><br></pre></td></tr></table></figure></div>

<p>这次的bug让我很懊恼，因为我确实考虑到了key已经存在的情况，但是由于我的考虑并不全面，所以出了这样的bug</p>
</li>
</ul>
<h2 id="第一单元心得体会"><a href="#第一单元心得体会" class="headerlink" title="第一单元心得体会"></a>第一单元心得体会</h2><p>​		第一单元的学习在每周二晚上拿到题目，周三开始住在咖啡厅、教室写代码和debug中<strong>艰难</strong>地度过。感觉最为困难的是第一次作业，因为毕竟是一个从零开始的新作业，也是第一次接触到OO。</p>
<p>​		经过这一单元的学习，我对递归下降有了一个全新的认识，也大概了解了面向对象的思想和方法。诚然，我对自己这几次作业是不太满意的，光从我的代码就可以看出来，思路并不清晰，架构没有那么漂亮，方法很繁琐，代码很冗长，这是一份可读性很差，bug又很多的代码。但是，从这三次作业中，我也收获了很多感悟，并下定决心（qwp）下一个单元在写代码之前一点要把架构想清楚，多使用层次化管理的方法，多简化自己的方法和代码，增加其可读性。而且，一定不要过了中测就沾沾自喜，不然就会有<strong>一堆bug</strong>在强测等着你(寄)，多分块测试自己代码的正确性。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>lab0上机总结</title>
    <url>/2023/03/07/myFirstBlog/</url>
    <content><![CDATA[<h1 id="lab0上机总结"><a href="#lab0上机总结" class="headerlink" title="lab0上机总结"></a>lab0上机总结</h1><ul>
<li><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote>
<h3 id="change-mode"><a href="#change-mode" class="headerlink" title="change mode"></a>change mode</h3><p> 文件调用权限：Owner、Group、Other Users</p>
<p> chmod [-cfvR] [–help] [–version] mode file…</p>
<ul>
<li><h3 id="mode-ugoa…-x3D-rwxX-…-…"><a href="#mode-ugoa…-x3D-rwxX-…-…" class="headerlink" title="mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]"></a>mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]</h3></li>
</ul>
<ol>
<li>u(user)表示该文件的拥有者，g(group)表示与该文件拥有者属于同一个group者，o(others)表示其他以外的人，a(all)表示这三者皆是</li>
<li>+表示增加权限，-表示取消权限，&#x3D;表示唯一设定权限</li>
<li>r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>八进制语法：文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。</li>
</ol>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>权限</th>
<th>rwx</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>读+写+执行</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>读+写</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>读+执行</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>只读</td>
<td>r–</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>写+执行</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>只写</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>只执行</td>
<td>–x</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>无</td>
<td>—</td>
<td>000</td>
</tr>
</tbody></table>
<p>例如，765 ：u对应7，g对应6，o对应5</p>
<ul>
<li><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><blockquote>
<p>tail [参数] [文件]</p>
<p>-f : 循环读取</p>
<p>-q : 不显示处理信息</p>
<p>-v : 显示详细的处理信息</p>
<p>-c&lt;数目&gt; 显示的字节数</p>
<p>-n&lt;行数&gt; 显示文件的尾部n行内容</p>
<p>tail file 默认显示最后10行</p>
<p>tail -n +10 表示从第十行到最后一行</p>
</blockquote>
</li>
<li><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote>
<p>awk ‘样式’ 文件 ：把符合样式的数据显示出来</p>
<p>awk {操作} 文件 ：对每一行都执行{}中的操作</p>
<p>awk ‘样式 {操作}’ 文件：对符合样式的数据行，执行{}中的操作</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>默认用空格或TAB分割 </p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>格式化输出</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指定分割字符</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F 字符串 &#x27;&#123;print ...&#125;&#x27; 文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置变量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -va=1 -vb=s &#x27;&#123;print $1,$1+a,$1b&#125;&#x27; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">输入</span><br><span class="line"> 2 3</span><br><span class="line"> 3 4</span><br><span class="line"> This&#x27;s 1</span><br><span class="line"> 10 11</span><br><span class="line">输出</span><br><span class="line"> 2 3 2s</span><br><span class="line"> 3 4 3s</span><br><span class="line"> This&#x27;s 1 This&#x27;ss</span><br><span class="line"> 10 11 10s</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h1><h2 id="1-获取文件总行数"><a href="#1-获取文件总行数" class="headerlink" title="1. 获取文件总行数"></a>1. 获取文件总行数</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n a.txt | tail -n 1 | awk &#x27;&#123;print$1&#125;&#x27;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-命令的返回值"><a href="#2-命令的返回值" class="headerlink" title="2. 命令的返回值"></a>2. 命令的返回值</h2><h4 id="用来获取上一个命令的退出状态，或者上一个函数的返回值。"><a href="#用来获取上一个命令的退出状态，或者上一个函数的返回值。" class="headerlink" title="$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。"></a>$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。</h4><p>比较两个文件，相同输出same，反之输出different</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">diff $file1 $file2 </span><br><span class="line">if[ $? == 0] then </span><br><span class="line">	echo &quot;same&quot;</span><br><span class="line">else	</span><br><span class="line">	encho &quot;different&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="返回值的用法"><a href="#返回值的用法" class="headerlink" title="返回值的用法"></a>返回值的用法</h3></li>
</ul>
<p>在 Linux 下，不管你是启动一个桌面程序也好，还是在控制台下运行命令，所有的程序在结束时，都会返回一个数字值，这个值叫做返回值，或者称为错误号 ( Error Number )。</p>
<p>在控制台下，有一个特殊的环境变量 **$?**，保存着前一个程序的返回值。如果变量 $? 的值不为0，就表示上一个命令在执行的过程中出错了。</p>
<p>那么如果返回的值不是 0，我们要怎么知道是那里出错了呢？ 大多数的程序出错都会给出提示，如果没有提示的话，可以用 <strong>perror</strong> 这个程序来查看错误的信息，比如返回值是 2，我们可以运行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perror 2</span></span><br><span class="line">OS error code   2:  No such file or directory</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="参数的用法"><a href="#参数的用法" class="headerlink" title="参数的用法"></a>参数的用法</h3><ul>
<li>$0 命令本身</li>
<li>$1 第一个参数</li>
<li>$# 参数的个数</li>
<li>$@ 参数列表（不包括命令本身）</li>
<li>$* ：和$@相同，但”$<em>“ 和 “$@”(加引号)并不同，”$</em>“将所有的参数解释成一个字符串，而”$@”是一个参数数组。</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...有参数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...没有参数</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/22/begin/</url>
    <content><![CDATA[<h1 id="update-blog"><a href="#update-blog" class="headerlink" title="update blog"></a>update blog</h1><ul>
<li><p>插入图片</p>
<p>使用 Github 作为图床在博文中插入图片</p>
<ul>
<li>在博客根目录下创建一个储存图片的文件夹<code>pictures</code>（或任何名字）</li>
<li>把需要插入的图片保存到<code>pictures</code>文件夹里并push到github远程仓库</li>
<li>在github仓库中打开图片，复制url，如 <a class="link" href="https://github.com/Yuleii/Yuleii.github.io/blob/master/pictures/test.PNG">https://github.com/Yuleii/Yuleii.github.io/blob/master/pictures/test.PNG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>将URL中blob替换为raw，即 <a class="link" href="https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG">https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>使用markdown插入图片的语法即可显示图片</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![test](https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG) </span><br></pre></td></tr></table></figure></div>


</li>
<li><p>发布博客</p>
</li>
</ul>
]]></content>
  </entry>
</search>
