<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/03/17/BUAA-OO-Unit1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="BUAA-OO-第一单元表达式展开"><a href="#BUAA-OO-第一单元表达式展开" class="headerlink" title="BUAA-OO 第一单元表达式展开"></a>BUAA-OO 第一单元表达式展开</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一单元主要通过对表达式结构进行建模，完成多变量多项式的括号展开，初步体会层次化设计思想。主要考察了Java基础语法和<strong>基本容器</strong>的使用，扩展BNF描述的形式化表述和<strong>正则表达式</strong>、<strong>递归下降</strong>等方法的使用。</p>
<p>本单元一共有三次作业，第一次作业是多变量表达式的展开化简，第二次作业加入三角函数和自定义函数的形式，第三次作业加入求导因子dx，dy，dz，又新增了求导功能。这三次作业难度是层层递进的，经过近一个月，第一单元的学习终于临近结束，在本篇博客里，我将详细分析这三次作业的框架结构和注意事项，并分享我学习第一单元的心得体会。</p>
<h2 id="基于度量来分析自己的程序结构"><a href="#基于度量来分析自己的程序结构" class="headerlink" title="基于度量来分析自己的程序结构"></a>基于度量来分析自己的程序结构</h2><h3 id="度量分析"><a href="#度量分析" class="headerlink" title="度量分析"></a>度量分析</h3><ul>
<li><strong>度量类的属性个数、方法个数、每个方法规模、每个方法的控制分支数目、类总代码规模</strong>，<strong>计算经典的OO度量</strong></li>
</ul>
<p>首先看下图的复杂度分析，<code>MyComparator</code>类、<code>Parser</code>类和<code>Definer</code>类的复杂度都很高</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/%E7%B1%BB%E7%9A%84OO%E5%BA%A6%E9%87%8F.png" alt="类的OO度量"></p>
<p>下面贴上<code>Parser</code>类方法的复杂度图</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/Parser%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%A6%E9%87%8F.png" alt="Parser内部方法的度量"></p>
<p>可以发现<code>parseFactor()</code>方法除了基本复杂度，其他指标都很高，它负责的工作很多，写的时候思路并没有那么清晰，需要结合注释理解才能看懂，增加了debug工作的难度。</p>
<h3 id="代码的UML类图"><a href="#代码的UML类图" class="headerlink" title="代码的UML类图"></a>代码的UML类图</h3><p>第一单元作业代码的<code>UML</code>类图如下所示</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/test.png" alt="UML1"></p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit1/Unit1UML.png" alt="test"></p>
<p><strong>分析类的内聚和相互间的耦合情况以及优缺点</strong></p>
<ul>
<li><p>各个类的设计考虑：</p>
<ul>
<li><p><code>Main</code>：主类，程序的主要流程</p>
</li>
<li><p><code>Definer</code>：解析自定义函数类，用于存储自定义函数定义、解析表达式中出现的自定义函数</p>
</li>
<li><p><code>Derivation</code>：求导因子类，用于存储表达式中出现的求导算子和被求导表达式</p>
</li>
<li><p><code>Expression</code>：表达式类，用于存储表达式或表达式因子</p>
</li>
<li><p><code>Factor</code>：因子类，用于存储因子类型和因子</p>
</li>
<li><p><code>FunFactor</code>：自定义函数因子类，用于存储自定义函数因子</p>
</li>
<li><p><code>Function</code>：幂函数因子类</p>
</li>
<li><p><code>Item</code>：单项式类</p>
</li>
<li><p><code>Lexer</code>：词法解析器</p>
</li>
<li><p><code>Multinomial</code>：多项式类</p>
</li>
<li><p><code>MyCompartor</code>：用于排序</p>
</li>
<li><p><code>Parser</code>：语法分析器</p>
</li>
<li><p><code>Process</code>：用于初步处理表达式，去除空白字符和化简加减号</p>
</li>
<li><p><code>Term</code>：项类</p>
</li>
<li><p><code>Token</code>：用于存储表达式中每类字符及其类型</p>
</li>
<li><p><code>TriangleFactor</code>：三角函数因子类</p>
</li>
</ul>
</li>
<li><p>设计缺点：</p>
<ul>
<li>应该将<code>Factor</code>设为接口，每次用type判断因子类型很麻烦，而且存储空间利用率小</li>
<li><code>MyComparator</code>类可以省去，因为按照x y z的指数排序其实并不重要</li>
<li><code>Lexer</code>类用正则表达式解析词法过于繁琐，用多重if-else判断增加复杂度</li>
<li><code>Process</code>类多余，直接化简即可</li>
<li>利用多项式单项式进行求导很繁琐，应该改为利用因子、项和表达式的特点进行层次化求导</li>
</ul>
</li>
<li><p>设计优点</p>
<ul>
<li>递归下降的使用</li>
<li>利用单项式多项式的结构处理表达式较为清晰，且很多方法可以复用如多项式的加法和乘法</li>
</ul>
</li>
</ul>
<h2 id="第一次作业分析"><a href="#第一次作业分析" class="headerlink" title="第一次作业分析"></a>第一次作业分析</h2><p>第一次作业的任务：读入一个包含加、减、乘、乘方以及括号的多变量表达式，输出恒等变形展开所有括号后的表达式。</p>
<p>其中，表达式由多个项加减而成，每个项由多个因子相乘得到。本次作业中因子包括变量因子（幂函数）、常数因子（带符号整数）、表达式因子（’(‘表达式’)’ [空白项 指数])</p>
<h3 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h3><p>分别建立<code>Expression</code>类、<code>Term</code>类、各种<code>Factor</code>类来存储表达式中各个元素。其中<code>Expression</code>类中用两个<code>Arraylist</code>分别存储<code>Term</code>和每个<code>Term</code>前的符号，<code>Term</code>类中用<code>Arraylist</code>存储每个<code>Factor</code>。</p>
<h4 id="递归下降解析表达式"><a href="#递归下降解析表达式" class="headerlink" title="递归下降解析表达式"></a>递归下降解析表达式</h4><p>首先用正则表达式构建<code>Lexer</code>类，即将表达式拆分成一个个字符类型。例如：<code>（x**2+y)*3</code>，解析得出<code>tokens</code>即为<code>(,x,**,2,+,y,),*,3</code></p>
<p><strong><code>Lexer</code>部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;	</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNKNOWN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(x|y|z)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXPONENTSIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\*\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="string">&quot;^\\s*([\\+\\-]?[0-9]+)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\+|\\-|\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEFT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\()&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\))&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FUNC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;f|g|h)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DOC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(,)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SINCOS</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(sin|cos)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DERIVATIVE</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(dx|dy|dz)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Lexer</span><span class="params">(String temp)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.position = <span class="number">0</span>;</span><br><span class="line">   		<span class="type">int</span> <span class="variable">des</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示可把符号作为第一项符号</span></span><br><span class="line">     	<span class="keyword">while</span> (des &lt; temp.length()) &#123;</span><br><span class="line">            <span class="comment">//正则匹配各个Token</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">back</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><code>Parser</code>类中包含上文解析所得的一个<code>Lexer</code>，然后就是各种解析方法，包括<code>parseFactor()</code>，<code>parseTerm()</code>，<code>parseExpr()</code>等。</p>
<p><strong>Parser部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Lexer lexer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLexer</span><span class="params">(Lexer lexer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lexer = lexer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">parseFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseFactor解析并返回Factor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Term <span class="title function_">parseTerm</span><span class="params">()</span> &#123;</span><br><span class="line">     	<span class="comment">//parseTerm解析并返回Term</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Expression <span class="title function_">parseExp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseExpr解析返回Expression</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> Function <span class="title function_">parsePowerFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parsePowerFunction解析并返回Function(幂函数因子)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="表达式展开"><a href="#表达式展开" class="headerlink" title="表达式展开"></a>表达式展开</h4><p>新建立两个类<code>Item</code>和<code>Multinomial</code>分别处理<strong>表达式展开后</strong>的单项式和多项式。</p>
<p><code>Item</code>类中含有系数<code>number</code>，x y z的指数<code>ex</code>、<code>ey</code>、<code>ez</code>，还有方法<code>toString()</code>将<strong>单项式转为字符串</strong>便于输出。</p>
<p><code>Multinomial</code>类中含有<code>Hashset</code>用于存储<code>Item</code>集合，以及方法<code>toString()</code>，还包括了<code>addFor()</code>,<code>mulFor()</code>,<code>powFor()</code>,<code>simplify()</code>分别进行多项式加法、乘法、乘方和<strong>多项式简化</strong>。</p>
<p><strong>powFor()的部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Multinomial <span class="title function_">powFor</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">       <span class="type">Multinomial</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();</span><br><span class="line">       <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">           result.items.add(item);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; temp;i++) &#123;</span><br><span class="line">           result = result.mulFor(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       result.simplify();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ul>
<li>在预处理表达式时，除了处理多个符号，还要记得去除所有<strong>空格</strong>和<strong>\t</strong> (第二次作业bug就出在这里o(╥﹏╥)o。</li>
<li>解析<code>parser</code>时一定要注意<code>lexer</code>的位置，多想几遍有没有多向前一步或者少向前一步，这个地方极易出bug</li>
<li>解析表达式因子时记得括号外面可能还会有指数！</li>
<li>优化时，记得判断最终结果是不是为空，为空就输出0</li>
</ul>
<h3 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第一次作业暂时未发现bug(事实证明只是没发现，并不是没有)</p>
<h2 id="第二次作业分析"><a href="#第二次作业分析" class="headerlink" title="第二次作业分析"></a>第二次作业分析</h2><p>第二次作业在第一次作业的基础上增加了一系列<strong>自定义函数</strong>和<strong>三角函数因子</strong></p>
<ul>
<li><p><em>三角函数因子</em>：类似于幂函数，由<code>sin(&lt;因子&gt;)</code>或<code>cos(&lt;因子&gt;)</code> 、指数符号<code>**</code>和指数组成</p>
</li>
<li><ul>
<li><p>自定义函数的定义：形如 <code>f(x, y, z) = 函数表达式</code> ，比如 <code>f(y) = y**2</code>  </p>
</li>
<li><p>自定义函数的<strong>调用</strong>形如 <code>f(因子, 因子, 因子)</code></p>
</li>
<li><p><code>x</code>、<code>y</code>、<code>z</code> 为函数的<strong>形参</strong>。在本次作业中，<strong>形参个数为 1~3 个</strong>。形参**只使用 <code>x</code>，<code>y</code>，<code>z</code>**，且同一函数定义中不会出现重复使用的形参</p>
</li>
<li><p><code>f</code> 、<code>g</code>、<code>h</code> 是函数的<strong>函数名</strong>。在本次作业中，保证函数名<strong>只使用 <code>f</code> ，<code>g</code>，<code>h</code><strong>，且</strong>不出现同名函数的重复定义</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义函数的解析"><a href="#自定义函数的解析" class="headerlink" title="自定义函数的解析"></a>自定义函数的解析</h3><p>对于自定义函数，新增了<code>FuncFactor</code>和<code>Definer</code>两个类，分别用来<strong>存储</strong>和<strong>解析</strong>自定义函数。对于<code>Lexer</code>和<code>Parser</code>类中也进行了改动。</p>
<ul>
<li><p><strong>Definer</strong></p>
<p><code>Definer</code>类中包含两个<code>Hashmap</code>，第一个<code>parameters</code>键值对为<code>&lt;String,Arraylist&lt;String&gt;&gt;</code>，用来存储函数名和形参集合映射；第二个<code>functions</code>键值对为<code>&lt;String,String&gt;</code>，用来存储函数名和函数定义式映射。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;String,ArrayList&lt;String&gt;&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，形参集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> HashMap&lt;String,String&gt; functions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，定义式</span></span><br></pre></td></tr></table></figure></div>



<p><code>Definer</code>类中还包括<code>addFunc()</code>和<code>callFunc()</code>两个方法，分别用来<strong>存储函数形参</strong>、<strong>定义式</strong>和处理表达式中的自定义函数。</p>
<p>对于开始输入自定义函数及其定义时，用<code>addFunc()</code>方法解析并存储对应函数名的定义式中各形参集合，存储并化简函数的定义式。</p>
<p>在处理完所有自定义函数后，解析表达式时若遇到自定义函数，则用<code>callFunc()</code>方法处理该部分。解析出表达式自定义函数中的实参，通过函数名，得到对应定义式和形参集合，将定义式中的<strong>形参替换为实参</strong>，再对替换完的字符串进行解析，得到最终表达式。</p>
<blockquote>
<p>注意：在用<code>replaceAll()</code>替换形参时，若有多个形参，可能会造成替换错误。所以，可以在存储函数自定义函数的定义式和形参时用u,v,w代替x,y,z,以免出错。</p>
</blockquote>
</li>
<li><p><strong>FuncFactor</strong></p>
<p><code>FuncFactor</code>类中包含一个<code>String</code>类型的<code>updateFunc</code>，表示将形参替换为实参后的字符串，还有一个<code>Expression</code>类型的<code>expression</code>，存储将前者字符串解析后的表达式。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncFactor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String updateFunc;<span class="comment">//实参带入后的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Expression expression;<span class="comment">//解析成表达式</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="三角函数的解析"><a href="#三角函数的解析" class="headerlink" title="三角函数的解析"></a>三角函数的解析</h3><p>对于三角函数，增加了<code>TriangleFactor</code>类用于存储三角函数；</p>
<p>在解析表达式方面对于<code>Lexer</code>类和<code>Parser</code>类进行了改动；</p>
<p>在表达式展开方面，对于Item类新增了两个<code>HashMap</code>，键值对均为&lt;<code>Multinomial</code>,<code>int</code>&gt;，分别用来存储sin集合和cos集合，其<code>toString()</code>方法也要进行修改。（PS：以sin为例，<code>Multinomial</code>为sin内部多项式，<code>int</code>为sin的指数）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">//单项式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ez;<span class="comment">//表示x，y，z的指数</span></span><br><span class="line">    <span class="keyword">private</span> BigInteger number;</span><br><span class="line">    <span class="comment">//sin()里多项式，三角函数指数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; sinUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; cosUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>对于<code>Multinominal</code>类对于加法、乘法、化简等方法做一些改动。</p>
<blockquote>
<p><strong>ATTENTION！！！</strong></p>
<ul>
<li>在实现<code>Multinominal</code>对象的运算时，对任何类最好都进行<strong>深克隆</strong>（浅克隆容易出bug）</li>
</ul>
<p>因为浅克隆只是复制了该对象的引用，当改变对象中变量的值时，被克隆对象的相应值也发生改变</p>
<ul>
<li>在对Multinomial进行合并同类项化简时，注意如果这个Multinomial中所有Item全部消除为0时（此时items为空），多加一个number为0的Item对象进Multinomial，表示此时多项式为0，防止运算时出现错误</li>
</ul>
</blockquote>
<p>对于<code>TriangleFactor</code>类，其中包含<code>String</code>类型的<code>type</code>，<code>Factor</code>类型的<code>factor</code>，<code>int</code>类型的<code>exp</code>，分别用来记录当前因子是sin|cos，存储三角函数内部因子和记录三角函数的指数。</p>
<blockquote>
<p>sin(0) &#x3D; 0</p>
<p>cos(0) &#x3D; 1</p>
</blockquote>
<p>为了便于三角函数的进一步化简即合并同类项，我在这里对<code>Multinominal</code>和<code>Item</code>类的<code>hashcode</code>和<code>equals</code>方法进行<strong>重写</strong>，重写代码如下：</p>
<p><strong>Item</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> (Item) o;</span><br><span class="line">		<span class="keyword">return</span> ex == item.ex &amp;&amp; ey == item.ey &amp;&amp; ez == item.ez 				&amp;&amp;Objects.equals(number, item.number)&amp;&amp; 					Objects.equals(sinUnit, item.sinUnit) &amp;&amp; 					Objects.equals(cosUnit, item.cosUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(ex, ey, ez, number, sinUnit, cosUnit);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>Multinomial</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Multinomial</span> <span class="variable">that</span> <span class="operator">=</span> (Multinomial) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(items, that.items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意，在重写了<code>hashcode</code>和<code>equals</code>方法后，在<code>Hashmap</code>和<code>Hashset</code>中用<code>Item</code>或<code>Multinomial</code>作为键时，添加元素时要<strong>提前判断该键是否已存在</strong>集合里，若已存在，对已有元素的int值进行累加，反之直接add。（若不加判断直接add，原数据会被覆盖）</p>
</blockquote>
<h3 id="BUG分析-1"><a href="#BUG分析-1" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第二次作业的强测很惨很惨，这也让我发现了第一次作业没发现的bug</p>
<ul>
<li>在中测时，发现了<code>Multinomial</code>类中表达式进行乘法、加法时出现的浅克隆的bug，这种情况我最后都修改成了深克隆，bug就修复完成了</li>
<li>在初步处理表达式时，没有把<code>\t</code>去除。我仅仅用了<code>replaceAll(&quot; &quot;,&quot;&quot;)</code>去除了所有空格，而忘记了<code>\t</code>也是题目中提到的空白字符www</li>
<li>最后，强测中发现我的sin(0)在<code>Item</code>类的<code>toString()</code>中转为字符串是”1”,但是应该是”0”啊啊啊啊啊</li>
</ul>
<h2 id="第三次作业解析"><a href="#第三次作业解析" class="headerlink" title="第三次作业解析"></a>第三次作业解析</h2><p>第三次作业在第二次作业的基础上，新增了<strong>求导算子</strong>的概念，作业要求仍是对表达式进行展开和化简，但是最终结果不能包括括号和求导算子。</p>
<ul>
<li><p><em>求导因子</em></p>
<ul>
<li>求导因子可以出现在很多位置，包括<strong>函数调用实参</strong>，<strong>函数定义表达式</strong>，<strong>三角函数内部</strong>。</li>
<li>由<code>dx(表达式)</code>,<code>dy(表达式)</code>,<code>dz(表达式)</code>三种算符构成，分别代表对表达式的x变量求导，对表达式的y变量求导，对表达式的z变量求导。</li>
<li>由于本单元表达式自变量有三个分别为x,y,z，因此<strong>这里的求导可以理解为偏导</strong>。</li>
<li>为了保证<strong>结果一致性</strong>，自定义函数内包含求导因子，当调用该函数时，先将自定义函数表达式求导后再代入实参。例如函数<code>h(x) = dx(x)</code>,自定义函数调用<code>h(sin(x)) = 1</code>而不是<code>h(sin(x))=cos(x)</code>。</li>
</ul>
</li>
<li><p><em>求导公式</em></p>
<p>本次作业可能用到的<strong>求导公式</strong>有：<br>$$<br>Ⅰ.当f(x)&#x3D;c（c为常数）时，f’(x)&#x3D;0<br>$$</p>
<p>$$<br>Ⅱ.当f(x)&#x3D;x^n （n&#x3D;0）时。f’(x)&#x3D;n \ast x ^ {n-1}<br>$$</p>
<p>$$<br>Ⅲ.当f(x)&#x3D;sin(x)时，f’(x)&#x3D;cos(x)<br>$$</p>
<p>$$<br>Ⅳ.当f(x)&#x3D;cos(x)时，f’(x)&#x3D;−sin(x)<br>$$</p>
<p>$$<br>Ⅴ.链式法则：[f(g(x))]’&#x3D;f’(g(x))g’(x)<br>$$</p>
<p>$$<br>Ⅵ.乘法法则：[f(x)g(x)]’&#x3D;f’(x)g(x)+f(x)g’(x)<br>$$</p>
</li>
</ul>
<h3 id="求导算子的实现"><a href="#求导算子的实现" class="headerlink" title="求导算子的实现"></a>求导算子的实现</h3><h4 id="求导因子的解析"><a href="#求导因子的解析" class="headerlink" title="求导因子的解析"></a>求导因子的解析</h4><p>本次作业新增了<code>Derivation</code>类，用于存储求导因子。修改了<code>Lexer</code>和<code>Parser</code>类，新增了求导因子的解析方法，和前几种因子写法类似。</p>
<p>Derivation类的部分代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derivation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//x|y|z</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Factor</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factor</span>();<span class="comment">//表达式因子(expr)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Multinomial</span> <span class="variable">processed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();<span class="comment">//已求导多项式</span></span><br><span class="line"> 	</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="求导方法的实现"><a href="#求导方法的实现" class="headerlink" title="求导方法的实现"></a>求导方法的实现</h4><p>由于所有因子、项、表达式最终都可转换为<strong>多项式</strong>，并且对多项式求导只需逐个对多项式中<strong>单项式求导</strong>，所得的求导结果相加即可求得最终结果，所以本文采用对多项式和单项式求导的方法解决对求导因子的化简。</p>
<p>因为Item的存储形式为 <code>number * x**ex * y**ey * z**ez * sinUnits * cosUnits </code>  ,根据求导公式的特点可将每个Item对象分为三部分 ：</p>
<ul>
<li>section 1：<code>( number * x**ex * y**ey * z**ez )</code></li>
<li>section 2：<code>(sinUnits)</code></li>
<li>section 3：<code>(cosUnits)</code></li>
</ul>
<p>整个Item即为这三部分相乘，那么根据乘法法则，单项式求导结果即为：</p>
<p>(1)’ * (2) * (3) + (2)’ * (1) * (3) + (3)’ * (1) * (2)</p>
<blockquote>
<p>(1)代表section 1 ，(2) 代表section 2 ，(3)代表section 3</p>
</blockquote>
<ol>
<li><p>对于<strong>section 1</strong> 的求导根据求导公式一次即可求出。</p>
</li>
<li><p>对于<strong>section 2</strong> 的求导：</p>
</li>
</ol>
<p>​	对于sin集合，遍历<code>Hashmap</code>，对于每次取得的**&lt;Multinomial,int&gt;** ,根据链式法则</p>
<ul>
<li>先判断int是否大于0，若等于0直接得出求导结果为0，若大于0则得出第一部分求导结果为exp * sin(Multinomial)**(exp -1)</li>
<li>再对sin本身求导，根据三角函数求导公式可得第二部分求导结果为cos(Multinomial)</li>
<li>再对Multinomial求导，用多项式求导方法返回求导结果</li>
<li>section 2求导结果即为这三部分相乘</li>
</ul>
<p>​	最终求导结果为<code>HashMap</code>中每个元素的求导结果乘其他各个元素，再一起相加。</p>
<ol start="3">
<li>对于<strong>section 3</strong> 的求导和section 2 部分类似，注意d(cos(x)) &#x3D; -sin(x)</li>
</ol>
<blockquote>
<p>ATTENTION</p>
<p>求导运算时也要时刻注意运用<strong>深克隆</strong>！！！</p>
</blockquote>
<h3 id="BUG分析-2"><a href="#BUG分析-2" class="headerlink" title="BUG分析"></a>BUG分析</h3><ul>
<li><p>这次作业主要发现的bug就是，用<code>Hashset</code>存储<code>Item</code>时，应当<strong>判断容器中是不是有相同key存在</strong></p>
<p>我一开始写法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前操作想要把item放入items中，如果有相同key，就删除原有key，再把item的系数加倍，放入items</span></span><br><span class="line"><span class="keyword">if</span> (items.contain(item)) &#123;</span><br><span class="line">	items.remove(item);</span><br><span class="line">	items.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>是不是看起来很合理！！！其实并不……因为我没有考虑到<strong>item系数加倍后的新item</strong>，在items容器中有没有<strong>重复的key</strong>！！！</p>
<p>最终我的修改如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(items.contains(item)) &#123;</span><br><span class="line"> 		result.deleteItem(item);<span class="comment">//删去原有item</span></span><br><span class="line">        item.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line">items.setItems(item);</span><br></pre></td></tr></table></figure></div>

<p>这次的bug让我很懊恼，因为我确实考虑到了key已经存在的情况，但是由于我的考虑并不全面，所以出了这样的bug</p>
</li>
</ul>
<h2 id="第一单元心得体会"><a href="#第一单元心得体会" class="headerlink" title="第一单元心得体会"></a>第一单元心得体会</h2><p>​		第一单元的学习在每周二晚上拿到题目，周三开始住在咖啡厅、教室写代码和debug中<strong>艰难</strong>地度过。感觉最为困难的是第一次作业，因为毕竟是一个从零开始的新作业，也是第一次接触到OO。</p>
<p>​		经过这一单元的学习，我对递归下降有了一个全新的认识，也大概了解了面向对象的思想和方法。诚然，我对自己这几次作业是不太满意的，光从我的代码就可以看出来，思路并不清晰，架构没有那么漂亮，方法很繁琐，代码很冗长，这是一份可读性很差，bug又很多的代码。但是，从这三次作业中，我也收获了很多感悟，并下定决心（qwp）下一个单元在写代码之前一点要把架构想清楚，多使用层次化管理的方法，多简化自己的方法和代码，增加其可读性。而且，一定不要过了中测就沾沾自喜，不然就会有<strong>一堆bug</strong>在强测等着你(寄)，多分块测试自己代码的正确性。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>lab0上机总结</title>
    <url>/2023/03/07/myFirstBlog/</url>
    <content><![CDATA[<h1 id="lab0上机总结"><a href="#lab0上机总结" class="headerlink" title="lab0上机总结"></a>lab0上机总结</h1><ul>
<li><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote>
<h3 id="change-mode"><a href="#change-mode" class="headerlink" title="change mode"></a>change mode</h3><p> 文件调用权限：Owner、Group、Other Users</p>
<p> chmod [-cfvR] [–help] [–version] mode file…</p>
<ul>
<li><h3 id="mode-ugoa…-x3D-rwxX-…-…"><a href="#mode-ugoa…-x3D-rwxX-…-…" class="headerlink" title="mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]"></a>mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]</h3></li>
</ul>
<ol>
<li>u(user)表示该文件的拥有者，g(group)表示与该文件拥有者属于同一个group者，o(others)表示其他以外的人，a(all)表示这三者皆是</li>
<li>+表示增加权限，-表示取消权限，&#x3D;表示唯一设定权限</li>
<li>r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>八进制语法：文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。</li>
</ol>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>权限</th>
<th>rwx</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>读+写+执行</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>读+写</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>读+执行</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>只读</td>
<td>r–</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>写+执行</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>只写</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>只执行</td>
<td>–x</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>无</td>
<td>—</td>
<td>000</td>
</tr>
</tbody></table>
<p>例如，765 ：u对应7，g对应6，o对应5</p>
<ul>
<li><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><blockquote>
<p>tail [参数] [文件]</p>
<p>-f : 循环读取</p>
<p>-q : 不显示处理信息</p>
<p>-v : 显示详细的处理信息</p>
<p>-c&lt;数目&gt; 显示的字节数</p>
<p>-n&lt;行数&gt; 显示文件的尾部n行内容</p>
<p>tail file 默认显示最后10行</p>
<p>tail -n +10 表示从第十行到最后一行</p>
</blockquote>
</li>
<li><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote>
<p>awk ‘样式’ 文件 ：把符合样式的数据显示出来</p>
<p>awk {操作} 文件 ：对每一行都执行{}中的操作</p>
<p>awk ‘样式 {操作}’ 文件：对符合样式的数据行，执行{}中的操作</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>默认用空格或TAB分割 </p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>格式化输出</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指定分割字符</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F 字符串 &#x27;&#123;print ...&#125;&#x27; 文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置变量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -va=1 -vb=s &#x27;&#123;print $1,$1+a,$1b&#125;&#x27; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">输入</span><br><span class="line"> 2 3</span><br><span class="line"> 3 4</span><br><span class="line"> This&#x27;s 1</span><br><span class="line"> 10 11</span><br><span class="line">输出</span><br><span class="line"> 2 3 2s</span><br><span class="line"> 3 4 3s</span><br><span class="line"> This&#x27;s 1 This&#x27;ss</span><br><span class="line"> 10 11 10s</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h1><h2 id="1-获取文件总行数"><a href="#1-获取文件总行数" class="headerlink" title="1. 获取文件总行数"></a>1. 获取文件总行数</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n a.txt | tail -n 1 | awk &#x27;&#123;print$1&#125;&#x27;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-命令的返回值"><a href="#2-命令的返回值" class="headerlink" title="2. 命令的返回值"></a>2. 命令的返回值</h2><h4 id="用来获取上一个命令的退出状态，或者上一个函数的返回值。"><a href="#用来获取上一个命令的退出状态，或者上一个函数的返回值。" class="headerlink" title="$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。"></a>$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。</h4><p>比较两个文件，相同输出same，反之输出different</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">diff $file1 $file2 </span><br><span class="line">if[ $? == 0] then </span><br><span class="line">	echo &quot;same&quot;</span><br><span class="line">else	</span><br><span class="line">	encho &quot;different&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="返回值的用法"><a href="#返回值的用法" class="headerlink" title="返回值的用法"></a>返回值的用法</h3></li>
</ul>
<p>在 Linux 下，不管你是启动一个桌面程序也好，还是在控制台下运行命令，所有的程序在结束时，都会返回一个数字值，这个值叫做返回值，或者称为错误号 ( Error Number )。</p>
<p>在控制台下，有一个特殊的环境变量 **$?**，保存着前一个程序的返回值。如果变量 $? 的值不为0，就表示上一个命令在执行的过程中出错了。</p>
<p>那么如果返回的值不是 0，我们要怎么知道是那里出错了呢？ 大多数的程序出错都会给出提示，如果没有提示的话，可以用 <strong>perror</strong> 这个程序来查看错误的信息，比如返回值是 2，我们可以运行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perror 2</span></span><br><span class="line">OS error code   2:  No such file or directory</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="参数的用法"><a href="#参数的用法" class="headerlink" title="参数的用法"></a>参数的用法</h3><ul>
<li>$0 命令本身</li>
<li>$1 第一个参数</li>
<li>$# 参数的个数</li>
<li>$@ 参数列表（不包括命令本身）</li>
<li>$* ：和$@相同，但”$<em>“ 和 “$@”(加引号)并不同，”$</em>“将所有的参数解释成一个字符串，而”$@”是一个参数数组。</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...有参数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...没有参数</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/22/begin/</url>
    <content><![CDATA[<h1 id="update-blog"><a href="#update-blog" class="headerlink" title="update blog"></a>update blog</h1><ul>
<li><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>使用 Github 作为图床在博文中插入图片</p>
<ul>
<li>在博客根目录下创建一个储存图片的文件夹<code>pictures</code>（或任何名字）</li>
<li>把需要插入的图片保存到<code>pictures</code>文件夹里并push到github远程仓库</li>
<li>在github仓库中打开图片，复制url，如 <a class="link" href="https://github.com/Yuleii/Yuleii.github.io/blob/master/pictures/test.PNG">https://github.com/Yuleii/Yuleii.github.io/blob/master/pictures/test.PNG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>将URL中blob替换为raw，即 <a class="link" href="https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG">https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>使用markdown插入图片的语法即可显示图片</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![test](https://github.com/Yuleii/Yuleii.github.io/raw/master/pictures/test.PNG) </span><br></pre></td></tr></table></figure></div>


</li>
<li><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean  //清除缓存文件db.json和已生成的静态文件public</span><br><span class="line">$ hexo g   //生成网站静态文件到默认设置的public文件夹</span><br><span class="line">$ hexo d   //部署网站到设定的仓库</span><br><span class="line">$ hexo new &quot;Hello Hexo&quot; 或 hexo n &quot;Hello Hexo&quot; 生成一个markdown文件骨架用于填写内容</span><br><span class="line"></span><br><span class="line">$ hexo generate 或 hexo g 写完博客后, 生成静态内容</span><br><span class="line">$ hexo server 或 hexo s 启动本地服务器可以先看一下效果</span><br><span class="line">$ hexo deploy 或 hexo d 发布到外网</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="markdown文件头部-支持多标签"><a href="#markdown文件头部-支持多标签" class="headerlink" title="markdown文件头部, 支持多标签"></a>markdown文件头部, 支持多标签</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Ubuntu下安装phpmyadmin</span><br><span class="line">date: 2015-07-17</span><br><span class="line">tags: [ubuntu, phpmyadmin]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>BUAA-OO-Unit2</title>
    <url>/2023/06/22/BUAA-OO-Unit2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本单元基本目标是模拟<strong>多线程实时电梯系统</strong>，来熟悉线程的创建、运行，熟悉多线程程序的设计方法。</p>
<p>该系统类似新主楼，初始六台电梯可以在1-11层之间运行。系统从输入中输入乘客的请求信息，程序进行模拟电梯运行时上下行、开关门和乘客的进出。</p>
<h2 id="多线程共享对象"><a href="#多线程共享对象" class="headerlink" title="多线程共享对象"></a>多线程共享对象</h2><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>如果多个线程同时读写共享变量，会出现<strong>数据不一致</strong>的问题，为了保证<strong>线程同步</strong>：</p>
<ul>
<li><p>对变量进行读取和写入时，结果要正确，必须保证是<strong>原子操作</strong>。原子操作是指不能被中断的一个或一系列操作</p>
</li>
<li><p>多线程模型下，要保证逻辑正确，对<strong>共享变量</strong>进行读写时，必须保证<strong>一组指令以原子方式执行</strong>：即某一个线程执行时，其他线程必须<strong>等待</strong></p>
</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>保证一段代码的原子性就是通过<strong>加锁和解锁</strong>实现的，这种加锁和解锁之间的代码块我们称之为<strong>临界区</strong>，任何时候临界区最多只有<strong>一个线程</strong>能执行。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁。</p>
<ul>
<li>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code></li>
<li>把<code>synchronized</code>逻辑封装起来，将一个类设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</li>
</ul>
<p>我在本次作业中利用<code>synchronized</code>关键字将<code>requestTable</code>类设计为线程安全类，当一个线程访问时，其他线程无法同时访问，进入等待状态。</p>
<blockquote>
<p><em><strong>ATTENTION</strong></em></p>
<ul>
<li>可重入锁 ：注意记录这是第几次获得锁</li>
</ul>
<p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong> (重复获取同一个锁 : 获取到锁以后继续获取同一个锁)</p>
<ul>
<li><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。为了避免死锁，线程<strong>获取锁的顺序要一致</strong></p>
</li>
<li><p>必须在加锁块中才能调用<code>wait()</code>方法。<code>wait()</code>方法调用时，会<strong><em>释放</em>线程获得的锁</strong>，<code>wait()</code>方法返回后，线程又会重新试图获得锁</p>
</li>
<li><p>同样的，必须在加锁块中才能调用<code>notify()</code>方法，调用后释放该锁，从而唤醒一个正在等待这个锁的线程，使得该等待线程从<code>wait()</code>方法返回</p>
</li>
</ul>
</blockquote>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>,<span class="literal">true</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//do something here</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure></div>

<p>信号量维护了一个信号量许可集。线程可以通过调用 <strong>acquire()</strong> 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须<strong>等待</strong>，直到有可用的许可为止。 线程可以通过 <strong>release()</strong> 来释放它所持有的信号量许可。</p>
<h1 id="代码的UML图"><a href="#代码的UML图" class="headerlink" title="代码的UML图"></a>代码的UML图</h1><ul>
<li>UML类图</li>
</ul>
<p>​	<img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit2/homework7_UML.png" alt="homework7_UML"></p>
<ul>
<li>时序图</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/pic_oo_unit2/UML%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="UML时序图"></p>
<h1 id="同步块设置即锁的选择"><a href="#同步块设置即锁的选择" class="headerlink" title="同步块设置即锁的选择"></a>同步块设置即锁的选择</h1><ul>
<li><p>本单元作业都采用<code>synchronized</code>锁</p>
</li>
<li><p>在前两次作业中设计了共享对象<code>requestTable</code>和<code>elevatorTable</code>分别管理请求队列和电梯系统中的电梯，同时保证这两个类的线程安全性，在涉及到多线程可同时读写的方法前加<code>synchronized</code>关键字，从而实现同步块的设计</p>
</li>
<li><p>其他加锁的地方仅有一处，即在判断电梯开门接人时，这时需要给<code>requestTable</code>对象加锁，以防其他线程改变<code>requestTable</code></p>
</li>
</ul>
<h1 id="第五次作业分析"><a href="#第五次作业分析" class="headerlink" title="第五次作业分析"></a>第五次作业分析</h1><p>本次作业基于前言无额外要求，作业难点主要在熟悉多线程程序的设计、电梯系统的调度策略、电梯的捎带策略等。</p>
<h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><h3 id="线程设计分析"><a href="#线程设计分析" class="headerlink" title="线程设计分析"></a>线程设计分析</h3><p>本次作业线程的设计使用<strong>生产者消费者模型</strong>，数据缓存区即<code>requestTable</code>类，所有的未完成请求都存在这里。</p>
<p>我一共设计了两类线程：</p>
<ul>
<li><code>InputHandler</code>为输入线程，即生产者，每次产生请求并添加到共享的请求队列中</li>
<li>Elevator为电梯线程，即消费者，每次从请求队列中拿取请求 （根据题目要求一共有六个电梯，所以设计了六个电梯线程）</li>
</ul>
<h3 id="电梯的捎带策略"><a href="#电梯的捎带策略" class="headerlink" title="电梯的捎带策略"></a>电梯的捎带策略</h3><p>本单元电梯捎带策略均采用<strong>LOOK策略</strong>，将该策略单独设置为一个类封装，供给电梯使用，架构清晰，方便以后调换策略（虽然后来并没有换OmO）</p>
<ol>
<li><p>首先判断现在是否有人上电梯或下电梯，如果有，电梯开门</p>
</li>
<li><p>否则（现在没有人上下电梯），如果电梯里有人，就按当前方向运行</p>
</li>
<li><p>否则（电梯里没有人且现在没有人上下电梯）</p>
<ul>
<li><p>如果请求队列里没有人，结合输入是否结束判断电梯是否应该结束，若不应该则等待</p>
</li>
<li><p>如果请求队列有人，判断当前方向是否有未添加请求，若有则电梯朝原方向前进，反之电梯翻转方向</p>
</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//实现策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RequestTable requestTable;</span><br><span class="line">    <span class="comment">//电梯的请求表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据当前电梯状态和requestTable获取电梯运行建议</span></span><br><span class="line">    <span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断在当前层是否有人可以上电梯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">ableComeIn</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断在当前层是否有人出电梯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ableComeOut</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测当前前进方向的楼层，有没有需要被添加的需求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">containCurDirection</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>



<h2 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li><p>注意加锁逻辑，不要造成<strong>死锁</strong></p>
</li>
<li><p>注意判断是否<strong>轮询</strong></p>
</li>
<li><p>线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务</p>
<ul>
<li>wait：调用wait()方法后，线程进入等待状态，wait()方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，wait()方法才会返回，然后，继续执行下一条语句</li>
<li>notify：让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回</li>
</ul>
</li>
</ul>
<h2 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h2><p>第一次交中测时cpu超时，第二次交real_time超时……第三次RTLE交替出现SOS</p>
<ul>
<li><p>CPU_TIME超时：</p>
<ul>
<li>极可能是因为<strong>轮询</strong>造成（对于轮询，可以在run方法中加一些输出来判断此时线程是否<strong>wait失败</strong>）</li>
<li>某个<strong>线程没有结束</strong>，这时可以查看自己的输入线程是否<code>close</code>、电梯线程结束条件是否正确（我是因为电梯线程判断结束条件出了一点小bug）</li>
</ul>
</li>
<li><p>REAL_TIME超时：</p>
<ul>
<li>程序中存在<strong>死锁</strong>（在可以改变wait判断条件的地方加<code>notifyAll</code>）</li>
<li>程序中存在死循环</li>
</ul>
</li>
</ul>
<h1 id="第六次作业分析"><a href="#第六次作业分析" class="headerlink" title="第六次作业分析"></a>第六次作业分析</h1><p>第六次作业在第五次作业的基础上，添加了模拟电梯系统<strong>扩建</strong>和日常<strong>维护</strong>时乘客的调度功能。对于新扩建的电梯，注意其载客量和运行速度可能会和初始电梯不同。</p>
<p>由于在本次作业中我仍然选择自由竞争的策略，所以调度方面没有太大的变化。</p>
<h2 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h2><ul>
<li>电梯系统的扩建</li>
</ul>
<p>对于新加电梯，考虑到方便统一管理电梯，我设计了一个类<code>elevatorTable</code>来存储所有电梯。其中，应特别注意这个类的<strong>线程安全问题</strong>，因为可能会有多个线程读写该共享电梯资源。</p>
<ul>
<li>日常维护<ul>
<li>对于输入线程接受到的maintain指令，应及时传递给电梯，这时用<code>elevatorTable</code>统一管理电梯就非常方便了</li>
<li>此时设置对应id的电梯的<strong>maintain位为1</strong>后，在电梯的<code>run</code>方法的while循环中判断，当maintain&#x3D;1则退出循环</li>
<li>这样可以保证电梯在执行完当前advice后<strong>立即</strong>停下来，然后在退出循环后电梯再将未到达目的地的乘客重新加入请求列表，这时注意<strong>更新</strong>这些乘客的起始楼层为当前楼层</li>
</ul>
</li>
</ul>
<p>​	</p>
<h2 id="注意细节-1"><a href="#注意细节-1" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li>注意判断电梯线程结束的条件。因为第五次作业中电梯线程结束当且仅当输入结束且请求队列为空时，但是在这次作业中当<strong>输入结束</strong>且<strong>请求队列为空</strong>时，仍可能有其他正在维修的电梯将乘客放出，所以电梯在此时不能结束</li>
<li>我在这里再次判断此时<strong>电梯系统是否有维修电梯</strong>，如果有则电梯线程不能结束</li>
<li>注意电梯应当在接受到maintain指令后尽可能快地维修</li>
</ul>
<h1 id="第七次作业分析"><a href="#第七次作业分析" class="headerlink" title="第七次作业分析"></a>第七次作业分析</h1><h2 id="调度器的选择"><a href="#调度器的选择" class="headerlink" title="调度器的选择"></a>调度器的选择</h2><blockquote>
<p>由于第五次第六次作业都未设计调度器而采用自由竞争的策略，所以仅在第七次作业中对调度器给予分析 </p>
</blockquote>
<p>在这次作业中我终于写了调度器www</p>
<ul>
<li>设计一个schedule线程，将总请求队列中的请求按照一定的策略分配给各个电梯的请求表（具体策略请移步下一个主题bfs换乘）</li>
<li>每次尝试从总表中取出一个请求，如果请求为空，则continue；反之将请求按策略加入分请求表</li>
<li>schedule线程结束条件：当总请求表为空、输入结束且<strong>每一个乘客都到达目的地时</strong>（注意这里，由于换乘时乘客当前目的地可能并不是最终目的地，此时还需将该乘客重新放入总请求表进行再次分配路线）</li>
</ul>
<h2 id="BFS求电梯换乘路线"><a href="#BFS求电梯换乘路线" class="headerlink" title="BFS求电梯换乘路线"></a>BFS求电梯换乘路线</h2><p>这里设计了Node和Reachable两个类用来计算乘客从出发层到目的层的可达路线，取出该路线中<strong>第一个目的楼层</strong>，随机分配一辆电梯执行该请求</p>
<ul>
<li>Node类存储bfs结点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> access;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//firstFloor和FirstId为对应找到的应搭乘电梯id和搭乘到多少层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstFloor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> access, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.access = access;</span><br><span class="line">        <span class="built_in">this</span>.firstFloor = first;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li>Reachable类用来分析一条可达的路线</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reachable</span> &#123;</span><br><span class="line">    <span class="comment">//分析一条请求的乘坐路线</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; accessTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//对应id电梯-&gt; access 集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start为当前楼层，end为目的楼层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Node <span class="title function_">workForPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">     	ArrayList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     	<span class="comment">//queue用来存储当前队列中的结点</span></span><br><span class="line">        ArrayList&lt;Node&gt; direct = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//direct用来存储可从start到end直达的电梯</span></span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>首先，对于<code>accessTable</code>中所有电梯，判断其是否能到达起始层，若可以则将其加入queue和direct</p>
</li>
<li><p>若direct非空，则任取一个电梯返回</p>
</li>
<li><p>否则，每次取queue的首个元素</p>
<ul>
<li>若其能到达终点，返回该结点</li>
<li>若不能，遍历<code>accessTable</code>中其他结点，若该电梯与头元素有重合可达层，将其加入queue</li>
</ul>
</li>
<li><p>最后，删除该头元素</p>
</li>
<li><p>判断队是否为空，若不为空则重复以上操作，反之退出循环</p>
</li>
</ul>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>对于控制每层的服务电梯和只接人电梯数量，我在电梯系统中设计了两个Semaphore类型的数组来控制。</p>
<p>在初始化时，设置每层资源数量分别为4和2。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Semaphore&gt; services = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Semaphore&gt; onlyPick = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ElevatorTable</span><span class="params">(Reachable reachable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reachable = reachable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">11</span>;i++) &#123;</span><br><span class="line">            services.add(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">4</span>));</span><br><span class="line">            onlyPick.add(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="注意细节-2"><a href="#注意细节-2" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li>判断电梯线程和调度线程结束当且仅当<strong>所有乘客都到达最终的目的地</strong>，具体实现可以在总请求列表中设置一个<code>totalNumber</code>位，当输入线程增加请求时该<code>totalNumber</code>加1；在乘客下车时判断其下车地点是否是最终目的的，若不是则将该请求重新加入总请求列表，若是则<code>totalNumber</code>减一</li>
</ul>
<p>​		当**<code>totalNumber</code>为0<strong>且</strong>输入结束**时线程可以结束</p>
<h2 id="BUG分析-1"><a href="#BUG分析-1" class="headerlink" title="BUG分析"></a>BUG分析</h2><ul>
<li>这次出了一个新bug，是由于schedule类在计算得出换乘电梯到将请求加入这个电梯的请求表的间隙，因为没有加锁导致错误。所以还是要多考虑加锁的逻辑，避免线程不安全出现。</li>
</ul>
<h1 id="第二单元心得体会"><a href="#第二单元心得体会" class="headerlink" title="第二单元心得体会"></a>第二单元心得体会</h1><ul>
<li>线程安全</li>
</ul>
<p>对于线程安全的设计，一开始对于加锁和释放锁的概念不清。后来随着不断学习多线程知识，总结锁的逻辑、wait和notify的用法，逐渐清晰了对线程安全的设计。</p>
<ul>
<li>层次化设计</li>
</ul>
<p>本单元的层次化设计大致体现在对类的封装和对象的引用上。比如，将电梯捎带策略strategy类封装成一个类放在电梯里，便于移植和更改；将advice单独建一个enum；建立一个电梯表类系统管理多个电梯等等。</p>
<p>经过本单元的学习，我对多线程程序设计有了一个初步的接触，也熟悉了很多设计模型。相比于第一单元的多项式展开，第二单元的设计相比要精简不少，整个代码的架构和风格也比上一单元好了很多（可能因为第一单元写的太乱了），希望下一单元继续努力完成每次作业www。</p>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
</search>
