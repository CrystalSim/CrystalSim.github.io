<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUAA-OO-Unit1总结</title>
    <url>/2023/03/07/BUAA-OO-Unit1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一单元主要通过对表达式结构进行建模，完成多变量多项式的括号展开，初步体会层次化设计思想。主要考察了Java基础语法和<strong>基本容器</strong>的使用，扩展BNF描述的形式化表述和<strong>正则表达式</strong>、<strong>递归下降</strong>等方法的使用。</p>
<p>本单元一共有三次作业，第一次作业是多变量表达式的展开化简，第二次作业加入三角函数和自定义函数的形式，第三次作业加入求导因子dx，dy，dz，又新增了求导功能。这三次作业难度是层层递进的，经过近一个月，第一单元的学习终于临近结束，在本篇博客里，我将详细分析这三次作业的框架结构和注意事项，并分享我学习第一单元的心得体会。</p>
<h2 id="基于度量来分析自己的程序结构"><a href="#基于度量来分析自己的程序结构" class="headerlink" title="基于度量来分析自己的程序结构"></a>基于度量来分析自己的程序结构</h2><h3 id="度量分析"><a href="#度量分析" class="headerlink" title="度量分析"></a>度量分析</h3><ul>
<li><strong>度量类的属性个数、方法个数、每个方法规模、每个方法的控制分支数目、类总代码规模</strong>，<strong>计算经典的OO度量</strong></li>
</ul>
<p>首先看下图的复杂度分析，<code>MyComparator</code>类、<code>Parser</code>类和<code>Definer</code>类的复杂度都很高</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit1/pic_oo_unit1/%E7%B1%BB%E7%9A%84OO%E5%BA%A6%E9%87%8F.png" alt="类的OO度量"></p>
<p>下面贴上<code>Parser</code>类方法的复杂度图</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit1/pic_oo_unit1/Parser%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%A6%E9%87%8F.png" alt="Parser内部方法的度量"></p>
<p>可以发现<code>parseFactor()</code>方法除了基本复杂度，其他指标都很高，它负责的工作很多，写的时候思路并没有那么清晰，需要结合注释理解才能看懂，增加了debug工作的难度。</p>
<h3 id="代码的UML类图"><a href="#代码的UML类图" class="headerlink" title="代码的UML类图"></a>代码的UML类图</h3><p>第一单元作业代码的<code>UML</code>类图如下所示</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit1/pic_oo_unit1/test.png" alt="UML1"></p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit1/pic_oo_unit1/Unit1UML.png" alt="test"></p>
<p><strong>分析类的内聚和相互间的耦合情况以及优缺点</strong></p>
<ul>
<li><p>各个类的设计考虑：</p>
<ul>
<li><p><code>Main</code>：主类，程序的主要流程</p>
</li>
<li><p><code>Definer</code>：解析自定义函数类，用于存储自定义函数定义、解析表达式中出现的自定义函数</p>
</li>
<li><p><code>Derivation</code>：求导因子类，用于存储表达式中出现的求导算子和被求导表达式</p>
</li>
<li><p><code>Expression</code>：表达式类，用于存储表达式或表达式因子</p>
</li>
<li><p><code>Factor</code>：因子类，用于存储因子类型和因子</p>
</li>
<li><p><code>FunFactor</code>：自定义函数因子类，用于存储自定义函数因子</p>
</li>
<li><p><code>Function</code>：幂函数因子类</p>
</li>
<li><p><code>Item</code>：单项式类</p>
</li>
<li><p><code>Lexer</code>：词法解析器</p>
</li>
<li><p><code>Multinomial</code>：多项式类</p>
</li>
<li><p><code>MyCompartor</code>：用于排序</p>
</li>
<li><p><code>Parser</code>：语法分析器</p>
</li>
<li><p><code>Process</code>：用于初步处理表达式，去除空白字符和化简加减号</p>
</li>
<li><p><code>Term</code>：项类</p>
</li>
<li><p><code>Token</code>：用于存储表达式中每类字符及其类型</p>
</li>
<li><p><code>TriangleFactor</code>：三角函数因子类</p>
</li>
</ul>
</li>
<li><p>设计缺点：</p>
<ul>
<li>应该将<code>Factor</code>设为接口，每次用type判断因子类型很麻烦，而且存储空间利用率小</li>
<li><code>MyComparator</code>类可以省去，因为按照x y z的指数排序其实并不重要</li>
<li><code>Lexer</code>类用正则表达式解析词法过于繁琐，用多重if-else判断增加复杂度</li>
<li><code>Process</code>类多余，直接化简即可</li>
<li>利用多项式单项式进行求导很繁琐，应该改为利用因子、项和表达式的特点进行层次化求导</li>
</ul>
</li>
<li><p>设计优点</p>
<ul>
<li>递归下降的使用</li>
<li>利用单项式多项式的结构处理表达式较为清晰，且很多方法可以复用如多项式的加法和乘法</li>
</ul>
</li>
</ul>
<h2 id="第一次作业分析"><a href="#第一次作业分析" class="headerlink" title="第一次作业分析"></a>第一次作业分析</h2><p>第一次作业的任务：读入一个包含加、减、乘、乘方以及括号的多变量表达式，输出恒等变形展开所有括号后的表达式。</p>
<p>其中，表达式由多个项加减而成，每个项由多个因子相乘得到。本次作业中因子包括变量因子（幂函数）、常数因子（带符号整数）、表达式因子（’(‘表达式’)’ [空白项 指数])</p>
<h3 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h3><p>分别建立<code>Expression</code>类、<code>Term</code>类、各种<code>Factor</code>类来存储表达式中各个元素。其中<code>Expression</code>类中用两个<code>Arraylist</code>分别存储<code>Term</code>和每个<code>Term</code>前的符号，<code>Term</code>类中用<code>Arraylist</code>存储每个<code>Factor</code>。</p>
<h4 id="递归下降解析表达式"><a href="#递归下降解析表达式" class="headerlink" title="递归下降解析表达式"></a>递归下降解析表达式</h4><p>首先用正则表达式构建<code>Lexer</code>类，即将表达式拆分成一个个字符类型。例如：<code>（x**2+y)*3</code>，解析得出<code>tokens</code>即为<code>(,x,**,2,+,y,),*,3</code></p>
<p><strong><code>Lexer</code>部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lexer</span> &#123;	</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNKNOWN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(x|y|z)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXPONENTSIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\*\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="string">&quot;^\\s*([\\+\\-]?[0-9]+)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGN</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\+|\\-|\\*)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEFT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\()&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;\\))&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FUNC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(?&lt;content&gt;f|g|h)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DOC</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(,)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SINCOS</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(sin|cos)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DERIVATIVE</span> <span class="operator">=</span> <span class="string">&quot;^\\s*(dx|dy|dz)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Lexer</span><span class="params">(String temp)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.position = <span class="number">0</span>;</span><br><span class="line">   		<span class="type">int</span> <span class="variable">des</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示可把符号作为第一项符号</span></span><br><span class="line">     	<span class="keyword">while</span> (des &lt; temp.length()) &#123;</span><br><span class="line">            <span class="comment">//正则匹配各个Token</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">back</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.position &lt; tokens.size();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><code>Parser</code>类中包含上文解析所得的一个<code>Lexer</code>，然后就是各种解析方法，包括<code>parseFactor()</code>，<code>parseTerm()</code>，<code>parseExpr()</code>等。</p>
<p><strong>Parser部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Lexer lexer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLexer</span><span class="params">(Lexer lexer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lexer = lexer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Factor <span class="title function_">parseFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseFactor解析并返回Factor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Term <span class="title function_">parseTerm</span><span class="params">()</span> &#123;</span><br><span class="line">     	<span class="comment">//parseTerm解析并返回Term</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Expression <span class="title function_">parseExp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parseExpr解析返回Expression</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> Function <span class="title function_">parsePowerFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parsePowerFunction解析并返回Function(幂函数因子)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="表达式展开"><a href="#表达式展开" class="headerlink" title="表达式展开"></a>表达式展开</h4><p>新建立两个类<code>Item</code>和<code>Multinomial</code>分别处理<strong>表达式展开后</strong>的单项式和多项式。</p>
<p><code>Item</code>类中含有系数<code>number</code>，x y z的指数<code>ex</code>、<code>ey</code>、<code>ez</code>，还有方法<code>toString()</code>将<strong>单项式转为字符串</strong>便于输出。</p>
<p><code>Multinomial</code>类中含有<code>Hashset</code>用于存储<code>Item</code>集合，以及方法<code>toString()</code>，还包括了<code>addFor()</code>,<code>mulFor()</code>,<code>powFor()</code>,<code>simplify()</code>分别进行多项式加法、乘法、乘方和<strong>多项式简化</strong>。</p>
<p><strong>powFor()的部分代码</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Multinomial <span class="title function_">powFor</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">       <span class="type">Multinomial</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();</span><br><span class="line">       <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">           result.items.add(item);</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; temp;i++) &#123;</span><br><span class="line">           result = result.mulFor(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       result.simplify();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><ul>
<li>在预处理表达式时，除了处理多个符号，还要记得去除所有<strong>空格</strong>和<strong>\t</strong> (第二次作业bug就出在这里o(╥﹏╥)o。</li>
<li>解析<code>parser</code>时一定要注意<code>lexer</code>的位置，多想几遍有没有多向前一步或者少向前一步，这个地方极易出bug</li>
<li>解析表达式因子时记得括号外面可能还会有指数！</li>
<li>优化时，记得判断最终结果是不是为空，为空就输出0</li>
</ul>
<h3 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第一次作业暂时未发现bug(事实证明只是没发现，并不是没有)</p>
<h2 id="第二次作业分析"><a href="#第二次作业分析" class="headerlink" title="第二次作业分析"></a>第二次作业分析</h2><p>第二次作业在第一次作业的基础上增加了一系列<strong>自定义函数</strong>和<strong>三角函数因子</strong></p>
<ul>
<li><p><em>三角函数因子</em>：类似于幂函数，由<code>sin(&lt;因子&gt;)</code>或<code>cos(&lt;因子&gt;)</code> 、指数符号<code>**</code>和指数组成</p>
</li>
<li><ul>
<li><p>自定义函数的定义：形如 <code>f(x, y, z) = 函数表达式</code> ，比如 <code>f(y) = y**2</code>  </p>
</li>
<li><p>自定义函数的<strong>调用</strong>形如 <code>f(因子, 因子, 因子)</code></p>
</li>
<li><p><code>x</code>、<code>y</code>、<code>z</code> 为函数的<strong>形参</strong>。在本次作业中，<strong>形参个数为 1~3 个</strong>。形参**只使用 <code>x</code>，<code>y</code>，<code>z</code>**，且同一函数定义中不会出现重复使用的形参</p>
</li>
<li><p><code>f</code> 、<code>g</code>、<code>h</code> 是函数的<strong>函数名</strong>。在本次作业中，保证函数名<strong>只使用 <code>f</code> ，<code>g</code>，<code>h</code><strong>，且</strong>不出现同名函数的重复定义</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义函数的解析"><a href="#自定义函数的解析" class="headerlink" title="自定义函数的解析"></a>自定义函数的解析</h3><p>对于自定义函数，新增了<code>FuncFactor</code>和<code>Definer</code>两个类，分别用来<strong>存储</strong>和<strong>解析</strong>自定义函数。对于<code>Lexer</code>和<code>Parser</code>类中也进行了改动。</p>
<ul>
<li><p><strong>Definer</strong></p>
<p><code>Definer</code>类中包含两个<code>Hashmap</code>，第一个<code>parameters</code>键值对为<code>&lt;String,Arraylist&lt;String&gt;&gt;</code>，用来存储函数名和形参集合映射；第二个<code>functions</code>键值对为<code>&lt;String,String&gt;</code>，用来存储函数名和函数定义式映射。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;String,ArrayList&lt;String&gt;&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，形参集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> HashMap&lt;String,String&gt; functions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//函数名，定义式</span></span><br></pre></td></tr></table></figure></div>



<p><code>Definer</code>类中还包括<code>addFunc()</code>和<code>callFunc()</code>两个方法，分别用来<strong>存储函数形参</strong>、<strong>定义式</strong>和处理表达式中的自定义函数。</p>
<p>对于开始输入自定义函数及其定义时，用<code>addFunc()</code>方法解析并存储对应函数名的定义式中各形参集合，存储并化简函数的定义式。</p>
<p>在处理完所有自定义函数后，解析表达式时若遇到自定义函数，则用<code>callFunc()</code>方法处理该部分。解析出表达式自定义函数中的实参，通过函数名，得到对应定义式和形参集合，将定义式中的<strong>形参替换为实参</strong>，再对替换完的字符串进行解析，得到最终表达式。</p>
<blockquote>
<p>注意：在用<code>replaceAll()</code>替换形参时，若有多个形参，可能会造成替换错误。所以，可以在存储函数自定义函数的定义式和形参时用u,v,w代替x,y,z,以免出错。</p>
</blockquote>
</li>
<li><p><strong>FuncFactor</strong></p>
<p><code>FuncFactor</code>类中包含一个<code>String</code>类型的<code>updateFunc</code>，表示将形参替换为实参后的字符串，还有一个<code>Expression</code>类型的<code>expression</code>，存储将前者字符串解析后的表达式。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncFactor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String updateFunc;<span class="comment">//实参带入后的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Expression expression;<span class="comment">//解析成表达式</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="三角函数的解析"><a href="#三角函数的解析" class="headerlink" title="三角函数的解析"></a>三角函数的解析</h3><p>对于三角函数，增加了<code>TriangleFactor</code>类用于存储三角函数；</p>
<p>在解析表达式方面对于<code>Lexer</code>类和<code>Parser</code>类进行了改动；</p>
<p>在表达式展开方面，对于Item类新增了两个<code>HashMap</code>，键值对均为&lt;<code>Multinomial</code>,<code>int</code>&gt;，分别用来存储sin集合和cos集合，其<code>toString()</code>方法也要进行修改。（PS：以sin为例，<code>Multinomial</code>为sin内部多项式，<code>int</code>为sin的指数）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="comment">//单项式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ez;<span class="comment">//表示x，y，z的指数</span></span><br><span class="line">    <span class="keyword">private</span> BigInteger number;</span><br><span class="line">    <span class="comment">//sin()里多项式，三角函数指数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; sinUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Multinomial,Integer&gt; cosUnit = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>对于<code>Multinominal</code>类对于加法、乘法、化简等方法做一些改动。</p>
<blockquote>
<p><strong>ATTENTION！！！</strong></p>
<ul>
<li>在实现<code>Multinominal</code>对象的运算时，对任何类最好都进行<strong>深克隆</strong>（浅克隆容易出bug）</li>
</ul>
<p>因为浅克隆只是复制了该对象的引用，当改变对象中变量的值时，被克隆对象的相应值也发生改变</p>
<ul>
<li>在对Multinomial进行合并同类项化简时，注意如果这个Multinomial中所有Item全部消除为0时（此时items为空），多加一个number为0的Item对象进Multinomial，表示此时多项式为0，防止运算时出现错误</li>
</ul>
</blockquote>
<p>对于<code>TriangleFactor</code>类，其中包含<code>String</code>类型的<code>type</code>，<code>Factor</code>类型的<code>factor</code>，<code>int</code>类型的<code>exp</code>，分别用来记录当前因子是sin|cos，存储三角函数内部因子和记录三角函数的指数。</p>
<blockquote>
<p>sin(0) &#x3D; 0</p>
<p>cos(0) &#x3D; 1</p>
</blockquote>
<p>为了便于三角函数的进一步化简即合并同类项，我在这里对<code>Multinominal</code>和<code>Item</code>类的<code>hashcode</code>和<code>equals</code>方法进行<strong>重写</strong>，重写代码如下：</p>
<p><strong>Item</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> (Item) o;</span><br><span class="line">		<span class="keyword">return</span> ex == item.ex &amp;&amp; ey == item.ey &amp;&amp; ez == item.ez 				&amp;&amp;Objects.equals(number, item.number)&amp;&amp; 					Objects.equals(sinUnit, item.sinUnit) &amp;&amp; 					Objects.equals(cosUnit, item.cosUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(ex, ey, ez, number, sinUnit, cosUnit);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>Multinomial</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Multinomial</span> <span class="variable">that</span> <span class="operator">=</span> (Multinomial) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(items, that.items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>注意，在重写了<code>hashcode</code>和<code>equals</code>方法后，在<code>Hashmap</code>和<code>Hashset</code>中用<code>Item</code>或<code>Multinomial</code>作为键时，添加元素时要<strong>提前判断该键是否已存在</strong>集合里，若已存在，对已有元素的int值进行累加，反之直接add。（若不加判断直接add，原数据会被覆盖）</p>
</blockquote>
<h3 id="BUG分析-1"><a href="#BUG分析-1" class="headerlink" title="BUG分析"></a>BUG分析</h3><p>第二次作业的强测很惨很惨，这也让我发现了第一次作业没发现的bug</p>
<ul>
<li>在中测时，发现了<code>Multinomial</code>类中表达式进行乘法、加法时出现的浅克隆的bug，这种情况我最后都修改成了深克隆，bug就修复完成了</li>
<li>在初步处理表达式时，没有把<code>\t</code>去除。我仅仅用了<code>replaceAll(&quot; &quot;,&quot;&quot;)</code>去除了所有空格，而忘记了<code>\t</code>也是题目中提到的空白字符www</li>
<li>最后，强测中发现我的sin(0)在<code>Item</code>类的<code>toString()</code>中转为字符串是”1”,但是应该是”0”啊啊啊啊啊</li>
</ul>
<h2 id="第三次作业解析"><a href="#第三次作业解析" class="headerlink" title="第三次作业解析"></a>第三次作业解析</h2><p>第三次作业在第二次作业的基础上，新增了<strong>求导算子</strong>的概念，作业要求仍是对表达式进行展开和化简，但是最终结果不能包括括号和求导算子。</p>
<ul>
<li><p><em>求导因子</em></p>
<ul>
<li>求导因子可以出现在很多位置，包括<strong>函数调用实参</strong>，<strong>函数定义表达式</strong>，<strong>三角函数内部</strong>。</li>
<li>由<code>dx(表达式)</code>,<code>dy(表达式)</code>,<code>dz(表达式)</code>三种算符构成，分别代表对表达式的x变量求导，对表达式的y变量求导，对表达式的z变量求导。</li>
<li>由于本单元表达式自变量有三个分别为x,y,z，因此<strong>这里的求导可以理解为偏导</strong>。</li>
<li>为了保证<strong>结果一致性</strong>，自定义函数内包含求导因子，当调用该函数时，先将自定义函数表达式求导后再代入实参。例如函数<code>h(x) = dx(x)</code>,自定义函数调用<code>h(sin(x)) = 1</code>而不是<code>h(sin(x))=cos(x)</code>。</li>
</ul>
</li>
<li><p><em>求导公式</em></p>
<p>本次作业可能用到的<strong>求导公式</strong>有：<br>$$<br>Ⅰ.当f(x)&#x3D;c（c为常数）时，f’(x)&#x3D;0<br>$$</p>
<p>$$<br>Ⅱ.当f(x)&#x3D;x^n （n&#x3D;0）时。f’(x)&#x3D;n \ast x ^ {n-1}<br>$$</p>
<p>$$<br>Ⅲ.当f(x)&#x3D;sin(x)时，f’(x)&#x3D;cos(x)<br>$$</p>
<p>$$<br>Ⅳ.当f(x)&#x3D;cos(x)时，f’(x)&#x3D;−sin(x)<br>$$</p>
<p>$$<br>Ⅴ.链式法则：[f(g(x))]’&#x3D;f’(g(x))g’(x)<br>$$</p>
<p>$$<br>Ⅵ.乘法法则：[f(x)g(x)]’&#x3D;f’(x)g(x)+f(x)g’(x)<br>$$</p>
</li>
</ul>
<h3 id="求导算子的实现"><a href="#求导算子的实现" class="headerlink" title="求导算子的实现"></a>求导算子的实现</h3><h4 id="求导因子的解析"><a href="#求导因子的解析" class="headerlink" title="求导因子的解析"></a>求导因子的解析</h4><p>本次作业新增了<code>Derivation</code>类，用于存储求导因子。修改了<code>Lexer</code>和<code>Parser</code>类，新增了求导因子的解析方法，和前几种因子写法类似。</p>
<p>Derivation类的部分代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Derivation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//x|y|z</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Factor</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factor</span>();<span class="comment">//表达式因子(expr)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Multinomial</span> <span class="variable">processed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Multinomial</span>();<span class="comment">//已求导多项式</span></span><br><span class="line"> 	</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="求导方法的实现"><a href="#求导方法的实现" class="headerlink" title="求导方法的实现"></a>求导方法的实现</h4><p>由于所有因子、项、表达式最终都可转换为<strong>多项式</strong>，并且对多项式求导只需逐个对多项式中<strong>单项式求导</strong>，所得的求导结果相加即可求得最终结果，所以本文采用对多项式和单项式求导的方法解决对求导因子的化简。</p>
<p>因为Item的存储形式为 <code>number * x**ex * y**ey * z**ez * sinUnits * cosUnits </code>  ,根据求导公式的特点可将每个Item对象分为三部分 ：</p>
<ul>
<li>section 1：<code>( number * x**ex * y**ey * z**ez )</code></li>
<li>section 2：<code>(sinUnits)</code></li>
<li>section 3：<code>(cosUnits)</code></li>
</ul>
<p>整个Item即为这三部分相乘，那么根据乘法法则，单项式求导结果即为：</p>
<p>(1)’ * (2) * (3) + (2)’ * (1) * (3) + (3)’ * (1) * (2)</p>
<blockquote>
<p>(1)代表section 1 ，(2) 代表section 2 ，(3)代表section 3</p>
</blockquote>
<ol>
<li><p>对于<strong>section 1</strong> 的求导根据求导公式一次即可求出。</p>
</li>
<li><p>对于<strong>section 2</strong> 的求导：</p>
</li>
</ol>
<p>​	对于sin集合，遍历<code>Hashmap</code>，对于每次取得的**&lt;Multinomial,int&gt;** ,根据链式法则</p>
<ul>
<li>先判断int是否大于0，若等于0直接得出求导结果为0，若大于0则得出第一部分求导结果为exp * sin(Multinomial)**(exp -1)</li>
<li>再对sin本身求导，根据三角函数求导公式可得第二部分求导结果为cos(Multinomial)</li>
<li>再对Multinomial求导，用多项式求导方法返回求导结果</li>
<li>section 2求导结果即为这三部分相乘</li>
</ul>
<p>​	最终求导结果为<code>HashMap</code>中每个元素的求导结果乘其他各个元素，再一起相加。</p>
<ol start="3">
<li>对于<strong>section 3</strong> 的求导和section 2 部分类似，注意d(cos(x)) &#x3D; -sin(x)</li>
</ol>
<blockquote>
<p>ATTENTION</p>
<p>求导运算时也要时刻注意运用<strong>深克隆</strong>！！！</p>
</blockquote>
<h3 id="BUG分析-2"><a href="#BUG分析-2" class="headerlink" title="BUG分析"></a>BUG分析</h3><ul>
<li><p>这次作业主要发现的bug就是，用<code>Hashset</code>存储<code>Item</code>时，应当<strong>判断容器中是不是有相同key存在</strong></p>
<p>我一开始写法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前操作想要把item放入items中，如果有相同key，就删除原有key，再把item的系数加倍，放入items</span></span><br><span class="line"><span class="keyword">if</span> (items.contain(item)) &#123;</span><br><span class="line">	items.remove(item);</span><br><span class="line">	items.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>是不是看起来很合理！！！其实并不……因为我没有考虑到<strong>item系数加倍后的新item</strong>，在items容器中有没有<strong>重复的key</strong>！！！</p>
<p>最终我的修改如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(items.contains(item)) &#123;</span><br><span class="line"> 		result.deleteItem(item);<span class="comment">//删去原有item</span></span><br><span class="line">        item.setNumber(item.getNumber().multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line">items.setItems(item);</span><br></pre></td></tr></table></figure></div>

<p>这次的bug让我很懊恼，因为我确实考虑到了key已经存在的情况，但是由于我的考虑并不全面，所以出了这样的bug</p>
</li>
</ul>
<h2 id="第一单元心得体会"><a href="#第一单元心得体会" class="headerlink" title="第一单元心得体会"></a>第一单元心得体会</h2><p>​		第一单元的学习在每周二晚上拿到题目，周三开始住在咖啡厅、教室写代码和debug中<strong>艰难</strong>地度过。感觉最为困难的是第一次作业，因为毕竟是一个从零开始的新作业，也是第一次接触到OO。</p>
<p>​		经过这一单元的学习，我对递归下降有了一个全新的认识，也大概了解了面向对象的思想和方法。诚然，我对自己这几次作业是不太满意的，光从我的代码就可以看出来，思路并不清晰，架构没有那么漂亮，方法很繁琐，代码很冗长，这是一份可读性很差，bug又很多的代码。但是，从这三次作业中，我也收获了很多感悟，并下定决心（qwp）下一个单元在写代码之前一点要把架构想清楚，多使用层次化管理的方法，多简化自己的方法和代码，增加其可读性。而且，一定不要过了中测就沾沾自喜，不然就会有<strong>一堆bug</strong>在强测等着你(寄)，多分块测试自己代码的正确性。</p>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OO-Unit2总结</title>
    <url>/2023/06/22/BUAA-OO-Unit2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本单元基本目标是模拟<strong>多线程实时电梯系统</strong>，来熟悉线程的创建、运行，熟悉多线程程序的设计方法。</p>
<p>该系统类似新主楼，初始六台电梯可以在1-11层之间运行。系统从输入中输入乘客的请求信息，程序进行模拟电梯运行时上下行、开关门和乘客的进出。</p>
<h2 id="多线程共享对象"><a href="#多线程共享对象" class="headerlink" title="多线程共享对象"></a>多线程共享对象</h2><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>如果多个线程同时读写共享变量，会出现<strong>数据不一致</strong>的问题，为了保证<strong>线程同步</strong>：</p>
<ul>
<li><p>对变量进行读取和写入时，结果要正确，必须保证是<strong>原子操作</strong>。原子操作是指不能被中断的一个或一系列操作</p>
</li>
<li><p>多线程模型下，要保证逻辑正确，对<strong>共享变量</strong>进行读写时，必须保证<strong>一组指令以原子方式执行</strong>：即某一个线程执行时，其他线程必须<strong>等待</strong></p>
</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>保证一段代码的原子性就是通过<strong>加锁和解锁</strong>实现的，这种加锁和解锁之间的代码块我们称之为<strong>临界区</strong>，任何时候临界区最多只有<strong>一个线程</strong>能执行。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁。</p>
<ul>
<li>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code></li>
<li>把<code>synchronized</code>逻辑封装起来，将一个类设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</li>
</ul>
<p>我在本次作业中利用<code>synchronized</code>关键字将<code>requestTable</code>类设计为线程安全类，当一个线程访问时，其他线程无法同时访问，进入等待状态。</p>
<blockquote>
<p><em><strong>ATTENTION</strong></em></p>
<ul>
<li>可重入锁 ：注意记录这是第几次获得锁</li>
</ul>
<p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong> (重复获取同一个锁 : 获取到锁以后继续获取同一个锁)</p>
<ul>
<li><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。为了避免死锁，线程<strong>获取锁的顺序要一致</strong></p>
</li>
<li><p>必须在加锁块中才能调用<code>wait()</code>方法。<code>wait()</code>方法调用时，会<strong><em>释放</em>线程获得的锁</strong>，<code>wait()</code>方法返回后，线程又会重新试图获得锁</p>
</li>
<li><p>同样的，必须在加锁块中才能调用<code>notify()</code>方法，调用后释放该锁，从而唤醒一个正在等待这个锁的线程，使得该等待线程从<code>wait()</code>方法返回</p>
</li>
</ul>
</blockquote>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>,<span class="literal">true</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//do something here</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure></div>

<p>信号量维护了一个信号量许可集。线程可以通过调用 <strong>acquire()</strong> 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须<strong>等待</strong>，直到有可用的许可为止。 线程可以通过 <strong>release()</strong> 来释放它所持有的信号量许可。</p>
<h1 id="代码的UML图"><a href="#代码的UML图" class="headerlink" title="代码的UML图"></a>代码的UML图</h1><ul>
<li>UML类图</li>
</ul>
<p>​	<img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit2/pic_oo_unit2/homework7_UML.png" alt="homework7_UML"></p>
<ul>
<li>时序图</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit2/pic_oo_unit2/UML%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="UML时序图"></p>
<h1 id="同步块设置即锁的选择"><a href="#同步块设置即锁的选择" class="headerlink" title="同步块设置即锁的选择"></a>同步块设置即锁的选择</h1><ul>
<li><p>本单元作业都采用<code>synchronized</code>锁</p>
</li>
<li><p>在前两次作业中设计了共享对象<code>requestTable</code>和<code>elevatorTable</code>分别管理请求队列和电梯系统中的电梯，同时保证这两个类的线程安全性，在涉及到多线程可同时读写的方法前加<code>synchronized</code>关键字，从而实现同步块的设计</p>
</li>
<li><p>其他加锁的地方仅有一处，即在判断电梯开门接人时，这时需要给<code>requestTable</code>对象加锁，以防其他线程改变<code>requestTable</code></p>
</li>
</ul>
<h1 id="第五次作业分析"><a href="#第五次作业分析" class="headerlink" title="第五次作业分析"></a>第五次作业分析</h1><p>本次作业基于前言无额外要求，作业难点主要在熟悉多线程程序的设计、电梯系统的调度策略、电梯的捎带策略等。</p>
<h2 id="代码架构分析"><a href="#代码架构分析" class="headerlink" title="代码架构分析"></a>代码架构分析</h2><h3 id="线程设计分析"><a href="#线程设计分析" class="headerlink" title="线程设计分析"></a>线程设计分析</h3><p>本次作业线程的设计使用<strong>生产者消费者模型</strong>，数据缓存区即<code>requestTable</code>类，所有的未完成请求都存在这里。</p>
<p>我一共设计了两类线程：</p>
<ul>
<li><code>InputHandler</code>为输入线程，即生产者，每次产生请求并添加到共享的请求队列中</li>
<li>Elevator为电梯线程，即消费者，每次从请求队列中拿取请求 （根据题目要求一共有六个电梯，所以设计了六个电梯线程）</li>
</ul>
<h3 id="电梯的捎带策略"><a href="#电梯的捎带策略" class="headerlink" title="电梯的捎带策略"></a>电梯的捎带策略</h3><p>本单元电梯捎带策略均采用<strong>LOOK策略</strong>，将该策略单独设置为一个类封装，供给电梯使用，架构清晰，方便以后调换策略（虽然后来并没有换OmO）</p>
<ol>
<li><p>首先判断现在是否有人上电梯或下电梯，如果有，电梯开门</p>
</li>
<li><p>否则（现在没有人上下电梯），如果电梯里有人，就按当前方向运行</p>
</li>
<li><p>否则（电梯里没有人且现在没有人上下电梯）</p>
<ul>
<li><p>如果请求队列里没有人，结合输入是否结束判断电梯是否应该结束，若不应该则等待</p>
</li>
<li><p>如果请求队列有人，判断当前方向是否有未添加请求，若有则电梯朝原方向前进，反之电梯翻转方向</p>
</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">//实现策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RequestTable requestTable;</span><br><span class="line">    <span class="comment">//电梯的请求表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据当前电梯状态和requestTable获取电梯运行建议</span></span><br><span class="line">    <span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断在当前层是否有人可以上电梯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">ableComeIn</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断在当前层是否有人出电梯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ableComeOut</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测当前前进方向的楼层，有没有需要被添加的需求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">containCurDirection</span><span class="params">()</span> &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>



<h2 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li><p>注意加锁逻辑，不要造成<strong>死锁</strong></p>
</li>
<li><p>注意判断是否<strong>轮询</strong></p>
</li>
<li><p>线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务</p>
<ul>
<li>wait：调用wait()方法后，线程进入等待状态，wait()方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，wait()方法才会返回，然后，继续执行下一条语句</li>
<li>notify：让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回</li>
</ul>
</li>
</ul>
<h2 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h2><p>第一次交中测时cpu超时，第二次交real_time超时……第三次RTLE交替出现SOS</p>
<ul>
<li><p>CPU_TIME超时：</p>
<ul>
<li>极可能是因为<strong>轮询</strong>造成（对于轮询，可以在run方法中加一些输出来判断此时线程是否<strong>wait失败</strong>）</li>
<li>某个<strong>线程没有结束</strong>，这时可以查看自己的输入线程是否<code>close</code>、电梯线程结束条件是否正确（我是因为电梯线程判断结束条件出了一点小bug）</li>
</ul>
</li>
<li><p>REAL_TIME超时：</p>
<ul>
<li>程序中存在<strong>死锁</strong>（在可以改变wait判断条件的地方加<code>notifyAll</code>）</li>
<li>程序中存在死循环</li>
</ul>
</li>
</ul>
<h1 id="第六次作业分析"><a href="#第六次作业分析" class="headerlink" title="第六次作业分析"></a>第六次作业分析</h1><p>第六次作业在第五次作业的基础上，添加了模拟电梯系统<strong>扩建</strong>和日常<strong>维护</strong>时乘客的调度功能。对于新扩建的电梯，注意其载客量和运行速度可能会和初始电梯不同。</p>
<p>由于在本次作业中我仍然选择自由竞争的策略，所以调度方面没有太大的变化。</p>
<h2 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h2><ul>
<li>电梯系统的扩建</li>
</ul>
<p>对于新加电梯，考虑到方便统一管理电梯，我设计了一个类<code>elevatorTable</code>来存储所有电梯。其中，应特别注意这个类的<strong>线程安全问题</strong>，因为可能会有多个线程读写该共享电梯资源。</p>
<ul>
<li>日常维护<ul>
<li>对于输入线程接受到的maintain指令，应及时传递给电梯，这时用<code>elevatorTable</code>统一管理电梯就非常方便了</li>
<li>此时设置对应id的电梯的<strong>maintain位为1</strong>后，在电梯的<code>run</code>方法的while循环中判断，当maintain&#x3D;1则退出循环</li>
<li>这样可以保证电梯在执行完当前advice后<strong>立即</strong>停下来，然后在退出循环后电梯再将未到达目的地的乘客重新加入请求列表，这时注意<strong>更新</strong>这些乘客的起始楼层为当前楼层</li>
</ul>
</li>
</ul>
<p>​	</p>
<h2 id="注意细节-1"><a href="#注意细节-1" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li>注意判断电梯线程结束的条件。因为第五次作业中电梯线程结束当且仅当输入结束且请求队列为空时，但是在这次作业中当<strong>输入结束</strong>且<strong>请求队列为空</strong>时，仍可能有其他正在维修的电梯将乘客放出，所以电梯在此时不能结束</li>
<li>我在这里再次判断此时<strong>电梯系统是否有维修电梯</strong>，如果有则电梯线程不能结束</li>
<li>注意电梯应当在接受到maintain指令后尽可能快地维修</li>
</ul>
<h1 id="第七次作业分析"><a href="#第七次作业分析" class="headerlink" title="第七次作业分析"></a>第七次作业分析</h1><h2 id="调度器的选择"><a href="#调度器的选择" class="headerlink" title="调度器的选择"></a>调度器的选择</h2><blockquote>
<p>由于第五次第六次作业都未设计调度器而采用自由竞争的策略，所以仅在第七次作业中对调度器给予分析 </p>
</blockquote>
<p>在这次作业中我终于写了调度器www</p>
<ul>
<li>设计一个schedule线程，将总请求队列中的请求按照一定的策略分配给各个电梯的请求表（具体策略请移步下一个主题bfs换乘）</li>
<li>每次尝试从总表中取出一个请求，如果请求为空，则continue；反之将请求按策略加入分请求表</li>
<li>schedule线程结束条件：当总请求表为空、输入结束且<strong>每一个乘客都到达目的地时</strong>（注意这里，由于换乘时乘客当前目的地可能并不是最终目的地，此时还需将该乘客重新放入总请求表进行再次分配路线）</li>
</ul>
<h2 id="BFS求电梯换乘路线"><a href="#BFS求电梯换乘路线" class="headerlink" title="BFS求电梯换乘路线"></a>BFS求电梯换乘路线</h2><p>这里设计了Node和Reachable两个类用来计算乘客从出发层到目的层的可达路线，取出该路线中<strong>第一个目的楼层</strong>，随机分配一辆电梯执行该请求</p>
<ul>
<li>Node类存储bfs结点</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> access;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//firstFloor和FirstId为对应找到的应搭乘电梯id和搭乘到多少层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstFloor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> access, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.access = access;</span><br><span class="line">        <span class="built_in">this</span>.firstFloor = first;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li>Reachable类用来分析一条可达的路线</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reachable</span> &#123;</span><br><span class="line">    <span class="comment">//分析一条请求的乘坐路线</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; accessTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//对应id电梯-&gt; access 集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//start为当前楼层，end为目的楼层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Node <span class="title function_">workForPath</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">     	ArrayList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     	<span class="comment">//queue用来存储当前队列中的结点</span></span><br><span class="line">        ArrayList&lt;Node&gt; direct = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//direct用来存储可从start到end直达的电梯</span></span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>首先，对于<code>accessTable</code>中所有电梯，判断其是否能到达起始层，若可以则将其加入queue和direct</p>
</li>
<li><p>若direct非空，则任取一个电梯返回</p>
</li>
<li><p>否则，每次取queue的首个元素</p>
<ul>
<li>若其能到达终点，返回该结点</li>
<li>若不能，遍历<code>accessTable</code>中其他结点，若该电梯与头元素有重合可达层，将其加入queue</li>
</ul>
</li>
<li><p>最后，删除该头元素</p>
</li>
<li><p>判断队是否为空，若不为空则重复以上操作，反之退出循环</p>
</li>
</ul>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>对于控制每层的服务电梯和只接人电梯数量，我在电梯系统中设计了两个Semaphore类型的数组来控制。</p>
<p>在初始化时，设置每层资源数量分别为4和2。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Semaphore&gt; services = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Semaphore&gt; onlyPick = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ElevatorTable</span><span class="params">(Reachable reachable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reachable = reachable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">11</span>;i++) &#123;</span><br><span class="line">            services.add(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">4</span>));</span><br><span class="line">            onlyPick.add(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="注意细节-2"><a href="#注意细节-2" class="headerlink" title="注意细节"></a>注意细节</h2><ul>
<li>判断电梯线程和调度线程结束当且仅当<strong>所有乘客都到达最终的目的地</strong>，具体实现可以在总请求列表中设置一个<code>totalNumber</code>位，当输入线程增加请求时该<code>totalNumber</code>加1；在乘客下车时判断其下车地点是否是最终目的的，若不是则将该请求重新加入总请求列表，若是则<code>totalNumber</code>减一</li>
</ul>
<p>​		当**<code>totalNumber</code>为0<strong>且</strong>输入结束**时线程可以结束</p>
<h2 id="BUG分析-1"><a href="#BUG分析-1" class="headerlink" title="BUG分析"></a>BUG分析</h2><ul>
<li>这次出了一个新bug，是由于schedule类在计算得出换乘电梯到将请求加入这个电梯的请求表的间隙，因为没有加锁导致错误。所以还是要多考虑加锁的逻辑，避免线程不安全出现。</li>
</ul>
<h1 id="第二单元心得体会"><a href="#第二单元心得体会" class="headerlink" title="第二单元心得体会"></a>第二单元心得体会</h1><ul>
<li>线程安全</li>
</ul>
<p>对于线程安全的设计，一开始对于加锁和释放锁的概念不清。后来随着不断学习多线程知识，总结锁的逻辑、wait和notify的用法，逐渐清晰了对线程安全的设计。</p>
<ul>
<li>层次化设计</li>
</ul>
<p>本单元的层次化设计大致体现在对类的封装和对象的引用上。比如，将电梯捎带策略strategy类封装成一个类放在电梯里，便于移植和更改；将advice单独建一个enum；建立一个电梯表类系统管理多个电梯等等。</p>
<p>经过本单元的学习，我对多线程程序设计有了一个初步的接触，也熟悉了很多设计模型。相比于第一单元的多项式展开，第二单元的设计相比要精简不少，整个代码的架构和风格也比上一单元好了很多（可能因为第一单元写的太乱了），希望下一单元继续努力完成每次作业www。</p>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OO-Unit3总结</title>
    <url>/2023/06/22/BUAA-OO-Unit3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元作业目标是实现简单的社交关系的模拟和查询、群组和消息功能及社交关系系统中不同消息类型以及相关操作，<strong>理解JML规格在面向对象设计与构造中的重要意义，并掌握利用JML规格提高代码质量的能力</strong>。</p>
<h2 id="本单元补充知识"><a href="#本单元补充知识" class="headerlink" title="本单元补充知识"></a>本单元补充知识</h2><h3 id="JML规格"><a href="#JML规格" class="headerlink" title="JML规格"></a>JML规格</h3><ul>
<li><p>前置条件requires ：requires子句定义方法的前置条件(precondition)。前置条件是对方法输入参数的限制，如果不满足前置条件，方法执行结果不可预测，或者说不保证方法执行结果的正确性。</p>
</li>
<li><p>后置条件ensures：对方法执行结果的限制，如果执行结果满足后置条件，则表示方法执行正确，否则执行错误。</p>
</li>
<li><p>副作用约定：副作用指方法在执行过程中对输入对象或 this 对象进行了修改（对其成员变量进行了赋值，或者调用其修改方法）</p>
<ul>
<li><p>modifiable语句：表示可修改；</p>
</li>
<li><p>assignable语句：表示可赋值；</p>
<p>assignable列出这个方法能够修改的类成员属性，如果后接\nothing关键词表示这个方法不对任何成员属性进行修改，是一个pure方法。</p>
</li>
</ul>
</li>
<li><p>规格变量的申明：如果是在Interface中声明规格变量，则要求明确变量的类别</p>
<ul>
<li><p>实例变量</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@public instance model non_null int []elements</span></span><br></pre></td></tr></table></figure></div>

<p>（不声明则默认是实例型的规格变量）</p>
</li>
<li><p>静态变量</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@public static model non_null int []elements</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>​	</p>
<h3 id="继承extends"><a href="#继承extends" class="headerlink" title="继承extends"></a>继承extends</h3><ul>
<li>子类继承父类时继承父类所有成员和方法，子类只需编写额外的功能</li>
</ul>
<blockquote>
<p>注意：子类自动获得了父类的所有字段，严禁定义与父类<strong>重名</strong>的字段！</p>
</blockquote>
<p>在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code></p>
<ul>
<li><p>继承有个特点，就是子类<strong>无法访问</strong>父类的<code>private</code>字段或者<code>private</code>方法</p>
</li>
<li><p>将<code>private</code>改为<code>protected</code>可以使子类访问父类的字段</p>
</li>
</ul>
<blockquote>
<p><code>protected</code>关键字可以把字段和方法的<strong>访问权限控制在继承树内部</strong>，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</p>
</blockquote>
<ul>
<li>super关键字表示父类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">       <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<ul>
<li><strong>子类不会继承任何父类的构造方法</strong></li>
</ul>
<h4 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h4><ol>
<li><p>把一个<strong>子类</strong>类型安全地变为<strong>父类</strong>类型的赋值，被称为向上转型（upcasting），向上转型实际上是把一个子类型安全地变为更加抽象的父类型。</p>
</li>
<li><p>如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）</p>
<ol>
<li><p>避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ol>
<h3 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h3><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现。如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code></p>
<ul>
<li>接口定义的所有方法默认都是<code>public abstract</code></li>
<li>一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字</li>
<li>一个类可以实现多个<code>interface</code></li>
<li><code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型</li>
</ul>
<h3 id="多态-Polymorphic"><a href="#多态-Polymorphic" class="headerlink" title="多态(Polymorphic)"></a>多态(Polymorphic)</h3><p>Java的实例方法调用是基于运行时的<strong>实际类型</strong>的动态调用，而<strong>非变量的声明类型</strong></p>
<p>多态的特性是:运行期才能动态决定调用的子类方法。</p>
<p>本次作业中实现的<code>MyMessage</code>类的构造方法中体现了多态这个思想。</p>
<h2 id="图模型构建和维护策略"><a href="#图模型构建和维护策略" class="headerlink" title="图模型构建和维护策略"></a>图模型构建和维护策略</h2><p>本单元的图模型主要为NetWork中的人员关系网和人员关系的权重构成。</p>
<h3 id="第九次作业"><a href="#第九次作业" class="headerlink" title="第九次作业"></a>第九次作业</h3><p>本次作业基于官方给出的社交网络整体框架，依据给出的JML表述实现<code>MyPerson</code>类和<code>MyNetWork</code>类以及各种异常类，实现相应的接口方法。本次作业中还针对<code>NetWork</code>类中的<code>query_triple_sum</code>方法书写OK测试。</p>
<ul>
<li><p>MyNetWork中并查集的构建</p>
<ul>
<li><p><code>isCircle</code>方法：将NetWork中的关系梳理成多个极大连通子集，每个子集中的成员都享有一个祖先，每次查询时只需要判断两个人是否有相同祖先即可。每次新添加成员相当于在网络中加入一个独立的子集，所以这时总子集个数加一；在每次给网络中两人添加关系时进行维护，取这两人的祖先进行判断，如果祖先不同，则将其中一个祖先的parent设为另一个祖先，相当于合并了这两个子集，同时总子集个数减一。</p>
</li>
<li><p><code>queryBlockSum</code>方法：每次只需返回网络中极大连通子图的个数即可。</p>
</li>
<li><p><code>query_triple_sum</code>方法：在每次给网络中两人添加关系时，遍历两人中其中一人的acquaintance，判断是否可以形成三角形，并记录三角形个数。</p>
</li>
</ul>
</li>
</ul>
<p>本次作业的难点主要在于NetWork类中<code>isCircle</code>方法、<code>queryBlockSum</code>方法和<code>queryTripleSum</code>方法的实现上。一开始我并没有考虑复杂度的问题 :cry:直接用BFS实现<code>isCircle</code>方法，判断两个人是否相连。后来发现这样复杂度过大:no_entry:性能较差，且容易超时，于是最后参考讨论区改成了并查集的实现方法。</p>
<h3 id="第十次作业"><a href="#第十次作业" class="headerlink" title="第十次作业"></a>第十次作业</h3><p>本次作业新增了Group和Message类以及一些新的异常类，对于NetWork类中一些方法也增加了一些新方法。在这次作业中新增了删除关系时有关图的维护。</p>
<ul>
<li><p>MyNetWork中并查集的重建</p>
<ul>
<li><p>由于在<code>modifyRelation</code>方法中可能会删除两人的关系，所以会涉及到并查集的重建。我采用的方法是在社交网络中设置脏位，初始值设为0。当删除了某两人的边时，将脏位置1，当调用需要使用并查集的方法时（isCircle、queryBlockSum），判断脏位是否为1，如果为1就重建整个并查集，并再次将脏位置0。</p>
</li>
<li><p>对于需要计算三角形个数的<code>query_triple_sum</code>方法，可以将计算出的所有的三角形用集合记录下来，每次删除边时，判断这条边是否在已经记录的三角形集合的某个三角形中，如果是则删除该三角形。</p>
</li>
</ul>
</li>
</ul>
<h3 id="第十一次作业"><a href="#第十一次作业" class="headerlink" title="第十一次作业"></a>第十一次作业</h3><p>本次作业新增了<code>RedEnvelopeMessage</code>类，<code>NoticeMessage</code>类，<code>EmojiMessage</code>类以及一些异常类。在这次作业中新增了网络关系中最小环的计算。</p>
<ul>
<li><p>MyNetWork中<code>queryLeastMoments</code>方法要求计算出通过pid的最小环并返回该环的长度</p>
<p>我参考了讨论区的方法用修改后的dijkstra方法实现了最小环的计算，具体步骤如下：</p>
<ul>
<li>初始化vis数组（标记该点是否加入)，paths数组（记录该点到pid的最短路径长度、路径中第二个点和次短路径长度、路径中第二个点）</li>
<li>每次取未加入且与pid权重最小的点v，将对应vis置1</li>
<li>遍历v的acquaintance，用v的最短路径长度和次短路径长度分别更新其acquaintance的最短路径和次短路径</li>
<li>最后遍历除pid之外所有成员，最小环长度就是最小的最短路径和次短路径之和</li>
</ul>
</li>
</ul>
<h2 id="OKTest"><a href="#OKTest" class="headerlink" title="OKTest"></a>OKTest</h2><p>在OKTest中，我们需要对JML的全部内容进行检查，除了检验requires和ensures，还有pure、assignable语句等等。例如，对于一个pure方法，调用方法前后的状态应该一致，如果前后状态不一致，那么我们认为这不符合给定的JML。所以OK测试可以检验代码实现与规格是否具有一致性。</p>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><ul>
<li><p>对黑箱测试，白箱测试的理解</p>
<ul>
<li><p>黑箱测试：黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。</p>
</li>
<li><p>白箱测试：白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。</p>
</li>
</ul>
</li>
<li><p>对单元测试、功能测试、集成测试、压力测试、回归测试的理解</p>
<ul>
<li><p>单元测试：单元测试是完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。</p>
</li>
<li><p>功能测试：功能测试（Functional Test）是在规定的一段时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。</p>
</li>
<li><p>集成测试：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。</p>
</li>
<li><p>压力测试：软件压力测试是一种基本的质量保证行为，它不是在常规条件下运行手动或自动测试，而是在计算机数量较少或系统资源匮乏的条件下运行测试。通常要进行软件压力测试的资源包括内部内存、CPU可用性、磁盘空间和网络带宽。压力测试涵盖，性能测试，负载测试，并发测试等等，这些测试点常常交织耦合在一起。</p>
</li>
<li><p>回归测试：当发现并修改缺陷后，或在软件中添加新的功能后，重新测试。用来检查被发现的缺陷是否被改正，并且所做的修改没有引发新的问题。回归测试可以通过人工重新执行测试用例，也可以使用自动化的工具来进行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="BUG分析"><a href="#BUG分析" class="headerlink" title="BUG分析"></a>BUG分析</h2><ul>
<li><p>对于第十次作业</p>
<ul>
<li><p>一开始没有注意Message的有序性，新的message应该添加到list的头部</p>
</li>
<li><p>想着<code>queryBestAcquaintance</code>方法计算bestId的时候复杂度只有O(n)，就没有设置缓存维护每个成员的bestId，导致强测有一个点ctle:sob:  </p>
<p>后来发现在<code>queryCoupleSum</code>方法中调用了<code>queryBestAcquaintance</code>方法，而按照我之前无脑循环的计算方法，时间复杂度达到了O(n^3)，所以会超时。最后对于以上两个方法都添加缓存后，修复了这个bug</p>
</li>
</ul>
</li>
<li><p>对于第十一次作业</p>
<ul>
<li><p>没有对queryLeastMement方法进行过多地优化，仅仅用修改后的dijkstra方法实现，而没有加优先队列每次选出队中权重最短的未选过的点，导致strong9这个点ctle:cry:</p>
<p>这一次又是之前知道这是一个优化方法，但是因为自己的惰性没有做更多的优化……只能说优化真的很重要。</p>
</li>
</ul>
</li>
</ul>
<h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>这一单元主要学习了JML的规格和OKtest测试，也进一步熟悉了规格和设计分离的思路。在完成本单元作业时，我感觉JML较为难读，对于自己写的实现方法是否符合题目的性能要求也不是很清楚 :anguished: 也非常感谢讨论区同学们热心分享的优化算法！希望自己在今后的学习中，能够更加关注时间复杂度以及程序性能方面的提升。</p>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OO-Unit4总结</title>
    <url>/2023/06/22/BUAA-OO-Unit4/</url>
    <content><![CDATA[<ul>
<li>总结本单元所实践的正向建模与开发</li>
<li>总结本单元作业的架构设计，并对比分析最终的代码设计和UML模型设计之间的追踪关系</li>
<li>总结自己在四个单元中架构设计思维的演进</li>
<li>总结自己在四个单元中测试思维的演进</li>
<li>总结自己的课程收获</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元将以一个图书馆模拟系统为例，锻炼同学们<strong>对程序架构的设计和抽象能力，以及加强对 UML 图的绘制训练</strong>，需要掌握 UML 图的相关知识，以及 StarUML 的使用方法。</p>
<h2 id="正向建模与开发"><a href="#正向建模与开发" class="headerlink" title="正向建模与开发"></a>正向建模与开发</h2><ul>
<li><p>正向建模指的是从需求分析出发，按照一定的规则和流程，将需求转换为软件的结构和功能，最终生成可执行的代码。在正向建模中，通常会使用一些建模工具和编程语言，如UML、Java等。正向建模是一种自上而下的开发方式，从高层次的抽象开始，逐步细化，直到生成可执行的代码。正向建模是软件开发的常规方式，是保证软件质量和可维护性的基础。</p>
</li>
<li><p>对于本单元作业，正向建模与开发的思想体现在首先根据图书馆模型和相应需求构建与设计模型，并将设计通过UML类图、状态图和时序图表现出来，最后再根据设计实现代码。</p>
</li>
</ul>
<h2 id="本单元架构设计"><a href="#本单元架构设计" class="headerlink" title="本单元架构设计"></a>本单元架构设计</h2><p>本单元三次作业主要设计并实验一个符合情景描述的图书馆模拟系统，同学们借阅图书需要遵守一定的规章制度。其中实现功能包括借书、还书、损毁书、修复书、查询书以及各学校图书馆之间的借还书等等。</p>
<p>本单元主要任务包括设计程序架构和绘制UML图。</p>
<h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p>主要实现了几种类，包括容器类、工具类、管理员类、图书馆类等</p>
<ul>
<li>容器类：<ul>
<li>Book：记录每种图书的类型、书号、副本数、学校名、学号、是否可以外借等</li>
<li>BookMessage：记录每条操作各信息，包括时间、学校名、学号、操作类型、书号及书的类型等</li>
</ul>
</li>
<li>工具类：<ul>
<li>MyCalendar：主要进行日期的计算、处理等</li>
</ul>
</li>
<li>管理员类：<ul>
<li>ArrangingLibrarian:实现整理管理员各功能</li>
<li>BrLibrarian：实现借还管理员各功能</li>
<li>LogisticsDivision：实现后勤处各功能</li>
<li>OrderingLibrarian：实现预定管理员各功能</li>
<li>SelfService：实现自助机器各功能</li>
<li>ManagementDivision：实现图书馆里处各功能</li>
</ul>
</li>
<li>图书馆类：<ul>
<li>Library：实现一个图书馆各功能，其中成员包含学校名、书架的书籍信息、学生的借书记录、学生损毁书记录、以及各管理员的实例</li>
<li>SchoolLibraryManage：对所有学校的图书馆进行统一管理</li>
</ul>
</li>
</ul>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p>
<p>本单元总体架构实现后我的UML类图即为下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit4/pic_oo_unit4/uml2.png"></p>
<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>状态图是系统分析的一种常用工具，它通过建立类对象的生存周期模型来描述对象随时间变化的动态行为。</p>
<p>一个状态图表示一个状态机，主要用于表现从一个状态到另一个状态的控制流。它不仅可以展现一个对象拥有的状态，还可以说明事件（如消息的接收、错误、条件变更等）如何随着时间的推移来影响这些状态。</p>
<p>状态图用于对系统的动态方面建模，动态方面指出现在系统结构中任一对象按事件排序的行为，其中这些对象可以是类、接口、构件和节点。</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit4/pic_oo_unit4/state.png"></p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p>
<p><img lazyload src="/images/loading.svg" data-src="https://github.com/CrystalSim/CrystalSim.github.io/raw/main/2023/06/22/BUAA-OO-Unit4/pic_oo_unit4/1.png"></p>
<h2 id="四个单元架构设计思维的演进及感想"><a href="#四个单元架构设计思维的演进及感想" class="headerlink" title="四个单元架构设计思维的演进及感想"></a>四个单元架构设计思维的演进及感想</h2><h3 id="第一单元：表达式解析"><a href="#第一单元：表达式解析" class="headerlink" title="第一单元：表达式解析"></a>第一单元：表达式解析</h3><p>感觉这一单元真的是四个单元中最难的一单元（可能因为刚接触面向对象的思想）说起来就是前几周的日子在每周二晚上拿到题目，周三开始住在咖啡厅、教室写代码和debug中<strong>艰难</strong>地度过:crying_cat_face:</p>
<p>本单元主要利用<strong>递归下降</strong>的思想对表达式进行解析、化简，也初次接触了层次化管理的思想。</p>
<p>经过这一单元的学习，我对面向对象的思想和方法有了一个全新的认识，也意识到了代码架构的重要性。因为第一单元我在思路不太清晰的情况下就直接开始敲代码，导致代码很冗长、架构不够漂亮、方法也很繁琐，可读性也很差，所以以后几单元中下意识开始注意自己的架构问题。</p>
<h3 id="第二单元：电梯调度"><a href="#第二单元：电梯调度" class="headerlink" title="第二单元：电梯调度"></a>第二单元：电梯调度</h3><p>第二单元实现模拟了多线程实时电梯系统，在这一单元我第一次接触并实现了多线程的程序，学习了很多新的知识和概念，比如线程的概念、各种锁、信号量、LOOK策略、自由竞争、调度器、轮询等等。</p>
<p>在这一单元我对类的封装更加熟练了，代码风格较上一单元有所提升，也对多线程程序设计有了一个初步的接触，熟悉了一些设计模型，如生产者-消费者模型、单例模式等等。</p>
<h3 id="第三单元：JML规格设计"><a href="#第三单元：JML规格设计" class="headerlink" title="第三单元：JML规格设计"></a>第三单元：JML规格设计</h3><p>本单元主要考察大家对JML规格实现和算法能力(?)</p>
<p>在本单元中我学习到了一些JML规格的知识，也认识并实现了一些图模型的算法，还有Oktest测试等内容，进一步熟悉了规格和设计分离的思路。在完成本单元作业时，我感觉JML较为难读，对于自己写的实现方法是否符合题目的性能要求也不是很清楚 :anguished: 也非常感谢讨论区同学们热心分享的优化算法！希望自己在今后的学习中，能够更加关注时间复杂度以及程序性能方面的提升。</p>
<h3 id="第四单元：UML建模语言"><a href="#第四单元：UML建模语言" class="headerlink" title="第四单元：UML建模语言"></a>第四单元：UML建模语言</h3><p>本单元主要锻炼同学们<strong>对程序架构的设计和抽象能力，以及加强对 UML 图的绘制训练</strong>。</p>
<p>在本单元中我进一步认识并学习了UML类图、时序图、状态图等相关知识，提高了自己理解题目的能力，也深刻意识到了设计构思的重要性。</p>
<h2 id="四个单元测试思维的演进"><a href="#四个单元测试思维的演进" class="headerlink" title="四个单元测试思维的演进"></a>四个单元测试思维的演进</h2><ul>
<li>Unit1自己的测试思维真的很弱，常常是过了中测就觉得万事大吉了:cry: 也因此出了很多bug，现在想想，如果当时自己有意识多测测应该也不会出这么多bug…</li>
<li>后来的单元自己就有意识地找同学对拍、用评测机进行测试，自己也有意识地构造容易错的测试点进行测试，降低了强测出bug的概率</li>
<li>后来随着逐渐深入地学习了解到了如黑盒测试、白盒测试、单元测试、自动化测试等多种测试方法</li>
<li>测试真的很重要，以后要多注重测试方面</li>
</ul>
<h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p><strong>OO课程完结撒花</strong>   :cherry_blossom: :cherry_blossom: :cherry_blossom: :cherry_blossom: :cherry_blossom: ✿ヽ(°▽°)✿ :cherry_blossom: :cherry_blossom: :cherry_blossom: :cherry_blossom: :cherry_blossom:</p>
<p>虽然一开始前几次作业感觉真的完成地很艰难，但是最后也都成功实现啦:happy:</p>
<p>而且经过一学期的学习，感觉自己的编程水平得到了进一步提高，从刚开始接触到逐渐熟悉面向对象的思想，学到了很多新的东西。虽然其间真的面对了很多困难，很多次因为作业而头疼，但最终还是逐步攻克了难关:grin: 真的非常感觉这一路走来给予过我帮助的老师、助教和同学们！:sob: </p>
]]></content>
      <tags>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>lab0上机总结</title>
    <url>/2023/03/07/myFirstBlog/</url>
    <content><![CDATA[<h1 id="lab0上机总结"><a href="#lab0上机总结" class="headerlink" title="lab0上机总结"></a>lab0上机总结</h1><ul>
<li><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote>
<h3 id="change-mode"><a href="#change-mode" class="headerlink" title="change mode"></a>change mode</h3><p> 文件调用权限：Owner、Group、Other Users</p>
<p> chmod [-cfvR] [–help] [–version] mode file…</p>
<ul>
<li><h3 id="mode-ugoa…-x3D-rwxX-…-…"><a href="#mode-ugoa…-x3D-rwxX-…-…" class="headerlink" title="mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]"></a>mode : [ugoa…] [ [+-&#x3D;] [rwxX]…] [,…]</h3></li>
</ul>
<ol>
<li>u(user)表示该文件的拥有者，g(group)表示与该文件拥有者属于同一个group者，o(others)表示其他以外的人，a(all)表示这三者皆是</li>
<li>+表示增加权限，-表示取消权限，&#x3D;表示唯一设定权限</li>
<li>r表示可读取，w表示可写入，x表示可执行，X表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>八进制语法：文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。</li>
</ol>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>#</th>
<th>权限</th>
<th>rwx</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>读+写+执行</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>读+写</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>读+执行</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>只读</td>
<td>r–</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>写+执行</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>只写</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>只执行</td>
<td>–x</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>无</td>
<td>—</td>
<td>000</td>
</tr>
</tbody></table>
<p>例如，765 ：u对应7，g对应6，o对应5</p>
<ul>
<li><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><blockquote>
<p>tail [参数] [文件]</p>
<p>-f : 循环读取</p>
<p>-q : 不显示处理信息</p>
<p>-v : 显示详细的处理信息</p>
<p>-c&lt;数目&gt; 显示的字节数</p>
<p>-n&lt;行数&gt; 显示文件的尾部n行内容</p>
<p>tail file 默认显示最后10行</p>
<p>tail -n +10 表示从第十行到最后一行</p>
</blockquote>
</li>
<li><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><blockquote>
<p>awk ‘样式’ 文件 ：把符合样式的数据显示出来</p>
<p>awk {操作} 文件 ：对每一行都执行{}中的操作</p>
<p>awk ‘样式 {操作}’ 文件：对符合样式的数据行，执行{}中的操作</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>默认用空格或TAB分割 </p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>格式化输出</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print &quot;%-8s %-10s\n&quot;,$1,$4&#125;&#x27; log.txt</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指定分割字符</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F 字符串 &#x27;&#123;print ...&#125;&#x27; 文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置变量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -va=1 -vb=s &#x27;&#123;print $1,$1+a,$1b&#125;&#x27; log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">输入</span><br><span class="line"> 2 3</span><br><span class="line"> 3 4</span><br><span class="line"> This&#x27;s 1</span><br><span class="line"> 10 11</span><br><span class="line">输出</span><br><span class="line"> 2 3 2s</span><br><span class="line"> 3 4 3s</span><br><span class="line"> This&#x27;s 1 This&#x27;ss</span><br><span class="line"> 10 11 10s</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h1><h2 id="1-获取文件总行数"><a href="#1-获取文件总行数" class="headerlink" title="1. 获取文件总行数"></a>1. 获取文件总行数</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n a.txt | tail -n 1 | awk &#x27;&#123;print$1&#125;&#x27;</span><br></pre></td></tr></table></figure></div>



<h2 id="2-命令的返回值"><a href="#2-命令的返回值" class="headerlink" title="2. 命令的返回值"></a>2. 命令的返回值</h2><h4 id="用来获取上一个命令的退出状态，或者上一个函数的返回值。"><a href="#用来获取上一个命令的退出状态，或者上一个函数的返回值。" class="headerlink" title="$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。"></a>$? 用来获取上一个命令的退出状态，或者上一个函数的返回值。</h4><p>比较两个文件，相同输出same，反之输出different</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">diff $file1 $file2 </span><br><span class="line">if[ $? == 0] then </span><br><span class="line">	echo &quot;same&quot;</span><br><span class="line">else	</span><br><span class="line">	encho &quot;different&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="返回值的用法"><a href="#返回值的用法" class="headerlink" title="返回值的用法"></a>返回值的用法</h3></li>
</ul>
<p>在 Linux 下，不管你是启动一个桌面程序也好，还是在控制台下运行命令，所有的程序在结束时，都会返回一个数字值，这个值叫做返回值，或者称为错误号 ( Error Number )。</p>
<p>在控制台下，有一个特殊的环境变量 **$?**，保存着前一个程序的返回值。如果变量 $? 的值不为0，就表示上一个命令在执行的过程中出错了。</p>
<p>那么如果返回的值不是 0，我们要怎么知道是那里出错了呢？ 大多数的程序出错都会给出提示，如果没有提示的话，可以用 <strong>perror</strong> 这个程序来查看错误的信息，比如返回值是 2，我们可以运行：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perror 2</span></span><br><span class="line">OS error code   2:  No such file or directory</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="参数的用法"><a href="#参数的用法" class="headerlink" title="参数的用法"></a>参数的用法</h3><ul>
<li>$0 命令本身</li>
<li>$1 第一个参数</li>
<li>$# 参数的个数</li>
<li>$@ 参数列表（不包括命令本身）</li>
<li>$* ：和$@相同，但”$<em>“ 和 “$@”(加引号)并不同，”$</em>“将所有的参数解释成一个字符串，而”$@”是一个参数数组。</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...有参数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">#...没有参数</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Begin a blog</title>
    <url>/2023/06/22/Begin-a-blog/</url>
    <content><![CDATA[<h1 id="update-blog"><a href="#update-blog" class="headerlink" title="update blog"></a>update blog</h1><ul>
<li><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>使用 Github 作为图床在博文中插入图片</p>
<ul>
<li>在博客根目录下创建一个储存图片的文件夹<code>pictures</code>（或任何名字）</li>
<li>把需要插入的图片保存到<code>pictures</code>文件夹里并push到github远程仓库</li>
<li>在github仓库中打开图片，复制url（图片地址）</li>
<li>将URL中blob替换为raw</li>
<li>使用markdown插入图片的语法即可显示图片</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![test](https://github.com/CrystalSim/CrystalSim.github.io/blob/main/pic_oo_unit2/homework7_UML.png) </span><br></pre></td></tr></table></figure></div>


</li>
<li><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean  //清除缓存文件db.json和已生成的静态文件public</span><br><span class="line">$ hexo g   //生成网站静态文件到默认设置的public文件夹</span><br><span class="line">$ hexo d   //部署网站到设定的仓库</span><br><span class="line">$ hexo new &quot;Hello Hexo&quot; 或 hexo n &quot;Hello Hexo&quot; 生成一个markdown文件骨架用于填写内容</span><br><span class="line"></span><br><span class="line">$ hexo generate 或 hexo g 写完博客后, 生成静态内容</span><br><span class="line">$ hexo server 或 hexo s 启动本地服务器可以先看一下效果</span><br><span class="line">$ hexo deploy 或 hexo d 发布到外网</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="markdown文件头部-支持多标签"><a href="#markdown文件头部-支持多标签" class="headerlink" title="markdown文件头部, 支持多标签"></a>markdown文件头部, 支持多标签</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Ubuntu下安装phpmyadmin</span><br><span class="line">date: 2015-07-17</span><br><span class="line">tags: [ubuntu, phpmyadmin]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <tags>
        <tag>begin</tag>
      </tags>
  </entry>
  <entry>
    <title>lab4-challenge 实验报告</title>
    <url>/2023/06/23/Lab4-Challenge/</url>
    <content><![CDATA[<h2 id="任务背景"><a href="#任务背景" class="headerlink" title="任务背景"></a>任务背景</h2><p>信号（英语：Signal）是 Unix、类 Unix 以及其他 POSIX 兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统会打断进程正常的控制流程，此时，任何非原子操作都将被打断。如果进程注册了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。信号的机制类似于硬件中断（异常），不同之处在于中断由处理器发出并由内核处理，而信号由内核发出并由用户程序处理。除了进程通过系统调用向另一进程（或它自身）发出的信号，内核还可以将发生的中断通过信号通知给引发中断的进程。如果说系统调用是一种用户程序通知内核的机制，那么信号就是内核通知用户程序的机制。</p>
<h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><h3 id="一、准备阶段"><a href="#一、准备阶段" class="headerlink" title="一、准备阶段"></a>一、准备阶段</h3><ul>
<li>在头文件中添加相关数据结构的定义如下：</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigset_t</span> &#123;</span>	<span class="comment">//信号集</span></span><br><span class="line">    <span class="type">int</span> sig[<span class="number">2</span>]; <span class="comment">//最多 32*2=64 种信号</span></span><br><span class="line">&#125;<span class="type">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span>	<span class="comment">//</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);    <span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;   <span class="comment">//运行信号处理函数过程中的信号掩码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> &#123;</span><span class="comment">//每个进程中的消息处理队列</span></span><br><span class="line">    <span class="type">int</span> signum;	<span class="comment">//信号编号</span></span><br><span class="line">    LIST_ENTRY(Message) sig_free_link;</span><br><span class="line">    LIST_ENTRY(Message) sig_wait_link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(sig_free_list, Message); </span><br><span class="line">LIST_HEAD(sig_wait_list, Message); </span><br><span class="line"><span class="comment">// sig_free_list，sig_wait_list代表Message连接而成的链表头的数据类型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<ul>
<li>在env进程块中添加定义如下，主要添加：<ul>
<li>进程要处理的信号链</li>
<li>该进程正在运行的信号的栈（重入）及对应栈顶</li>
<li>信号处理入口</li>
<li>该进程对应的掩码</li>
<li>该进程对应64个信号的处理结构体</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sig_wait_list</span> <span class="title">env_sigList</span>;</span>	<span class="comment">//该进程要处理的信号链</span></span><br><span class="line">	<span class="type">int</span> env_running_sig[<span class="number">100</span>];	<span class="comment">//该进程当前正在运行的信号栈</span></span><br><span class="line">	<span class="type">int</span> env_sig_top;	<span class="comment">//对应正在处理的信息栈顶</span></span><br><span class="line">	u_int env_user_signal_entry;</span><br><span class="line">	<span class="comment">//信号处理入口</span></span><br><span class="line"></span><br><span class="line">	<span class="type">sigset_t</span> env_mask;	<span class="comment">//该进程对应的掩码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">env_sigaction</span>[65];</span>	<span class="comment">//该进程信号处理结构体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="二、信号的注册"><a href="#二、信号的注册" class="headerlink" title="二、信号的注册"></a>二、信号的注册</h3><p>信号的注册函数采用下面的函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>signum</code> 表示需要处理信号的编号，<code>act</code> 表示新的信号处理结构体，旧的信号处理结构体则需要在 <code>oldact != NULL</code> 时保存该指针在对应的地址空间中。</p>
<p>该函数为当前进程注册处理函数，若成功则返回0，反之返回-1（如signum不合法，act为空等）</p>
<ul>
<li>信号注册实际上就是修改对应进程控制块 <code>env_sigaction[signum]</code>中的信号处理函数，所以需要用系统调用来陷入内核</li>
<li>我在用户态的函数实现都放在user&#x2F;lib&#x2F;signal.c文件下，其中修改进程掩码及向进程发送信号都需要陷入内核进行操作</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (act == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oldact != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		*oldact = curenv-&gt;env_sigaction[signum];</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_sigaction[signum] = (*act);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="三、信号的发送"><a href="#三、信号的发送" class="headerlink" title="三、信号的发送"></a>三、信号的发送</h3><p>发送信号操作在用户态执行下面的函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kill(u_int envid, int sig);</span><br></pre></td></tr></table></figure></div>

<p>然后进行系统调用陷入内核后，主要实现函数为kern&#x2F;env.c中的insertHeadSig函数，具体实现如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertHeadSig</span><span class="params">(<span class="type">int</span> envid, <span class="type">int</span> signum)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">target</span>;</span></span><br><span class="line">	<span class="comment">//进程号不合法(signum不合法在之前已经检查过)</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;target, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//env下的sigFreeList为空</span></span><br><span class="line">	<span class="keyword">if</span> (LIST_EMPTY(&amp;sigFreeList)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取freelist的头元素sig</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Message</span> *<span class="title">sig</span> =</span> LIST_FIRST(&amp;sigFreeList);</span><br><span class="line">	LIST_REMOVE(sig, sig_free_link);</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(sig, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Message));</span><br><span class="line">	<span class="comment">//设置sig的信息编号</span></span><br><span class="line">	sig-&gt;signum = signum;</span><br><span class="line">	<span class="comment">//插入target对应等待队列队头</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;target-&gt;env_sigList, sig, sig_wait_link);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要思路就是先排除不合法情况，然后从free队列中取一个Message将其初始化，并记录信号编号，然后将这个信号插入envid对应进程块即将处理信号队列的头部（优先处理）</p>
<h3 id="四、信号的处理"><a href="#四、信号的处理" class="headerlink" title="四、信号的处理"></a>四、信号的处理</h3><p>信号的处理是lab4-challenge一大难点:cry:</p>
<ul>
<li><p>当进程被调度在之后继续运行时，首先需要处理自身收到的所有信号，对于后面来的信号，认为其优先级更高而先进行处理。对于被阻塞信号，<strong>保留</strong>其信号信息。对于未阻塞信号，则需要跳转到信号处理函数，如果未注册处理函数，则按照默认的处理动作进行。</p>
</li>
<li><p>主要问题是信号的处理函数一般在用户态，但是信号的处理函数等信息保存在内核（env进程块中），所以我们在处理信号时需要读取内核态的待处理信号编号及其处理函数地址，再返回用户态进行处理。</p>
</li>
<li><p>而且进程必须处理完<strong>所有的未阻塞信号</strong>，当进程在一个信号处理函数中，也可能接收到其他新的信号；</p>
<p>这时应当<strong>保存此时的上下文环境</strong>，接受并处理新的信号后再返回原来的位置</p>
</li>
</ul>
<p>对于此我的做法是在每次陷入内核前调用do_signal信号处理函数，下面这个部分保证在处理完异常之后，恢复现场之前，调用do_signal函数，处理进程的信号</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">	move    a0, sp 	# 给do_siganl传入参数</span><br><span class="line">	addiu   sp, sp, -8</span><br><span class="line">	nop</span><br><span class="line">	jal     do_signal</span><br><span class="line">	nop</span><br><span class="line">	addiu   sp, sp, 8	</span><br><span class="line">	RESTORE_SOME</span><br><span class="line">	lw      k0, TF_EPC(sp)</span><br><span class="line">	lw      sp, TF_REG29(sp) /* Deallocate stack */</span><br><span class="line">.set noreorder</span><br><span class="line">	jr      k0</span><br><span class="line">	rfe</span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure></div>

<p>进程信号的具体处理实现如下：</p>
<ol>
<li><p>遍历该进程等待队列的信号，判断现在是否在一个信号处理函数中(即重入情况)</p>
<ul>
<li>如果在重入情况，则取进程中这个被打断执行信号的对应掩码判断信号是否需要被阻塞</li>
<li>如果不是，则根据当前进程掩码的对应位置判断信号是否需要被阻塞</li>
</ul>
</li>
<li><p>如果该信号没有被阻塞，则从等待队列中移出，进行处理</p>
</li>
<li><p>处理时，如果该进程有注册相应的处理函数，或者信号编号为SIG_SEGV或SIG_KILL或SIG_TERM，才进行处理，反之默认不处理</p>
</li>
<li><p>跳转到处理函数前，先将当前的Trapframe压入异常处理栈，再将此时的现场保存在新的TrampFrame中，具体实现代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curenv-&gt;env_sigaction[signum].sa_handler != <span class="literal">NULL</span></span><br><span class="line">   || signum == SIG_SEGV|| signum==SIG_KILL || signum==SIG_TERM) &#123;</span><br><span class="line">       <span class="comment">//处理</span></span><br><span class="line">       <span class="comment">//将发生异常时的现场保存在tmp_tf中</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">temp</span> =</span> *tf;</span><br><span class="line">       <span class="comment">//如果用户的栈指针不在异常处理栈，就将栈指针指向异常处栈</span></span><br><span class="line">       <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">           tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将当前的Trapframe压入异常处理栈中</span></span><br><span class="line">       tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">       *(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = temp;</span><br><span class="line">       <span class="comment">//如果用户已经注册了信号处理函数	</span></span><br><span class="line">       <span class="keyword">if</span>(curenv-&gt;env_user_signal_entry) &#123;</span><br><span class="line">           <span class="comment">//将指向Trampfram的指针放入a0 并在栈上为该参数分配空间</span></span><br><span class="line">           tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">           tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]); </span><br><span class="line">           <span class="comment">//将signum放入a1 并在栈上为其分配空间</span></span><br><span class="line">           tf-&gt;regs[<span class="number">5</span>] = signum;</span><br><span class="line">           tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">5</span>]);</span><br><span class="line">           <span class="comment">//将处理函数放入a2 并在栈上为其分配空间</span></span><br><span class="line">           tf-&gt;regs[<span class="number">6</span>] = curenv-&gt;env_sigaction[signum].sa_handler;</span><br><span class="line">           tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">6</span>]);</span><br><span class="line">           <span class="comment">//将该信号压入信号处理栈</span></span><br><span class="line">           sys_push_sig(signum);</span><br><span class="line">           <span class="comment">//将EPC置为用户态的信号处理函数</span></span><br><span class="line">           <span class="comment">//这样在进程返回用户态运行时，就会执行用户态处理函数，进行信号处理</span></span><br><span class="line">           tf-&gt;cp0_epc = curenv-&gt;env_user_signal_entry;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="五、细节实现"><a href="#五、细节实现" class="headerlink" title="五、细节实现"></a>五、细节实现</h3><ul>
<li><p>进程的初始化</p>
<ul>
<li><p>在env.c 中维护256个初始信号并将它们插入一个空free信号队列，每次发送新信号时从中取出</p>
</li>
<li><p>在进程被创建时将其所有新增加成员初始化，包括将64个处理函数置NULL，掩码清空，信息栈顶设为-1等</p>
</li>
</ul>
</li>
<li><p>当用户程序访问了页表中未映射且地址严格小于 <code>0x3FE000</code> 的虚拟页时需要被动向自身进程发送SIGSEGV信号，此处实现在kern&#x2F;tlbex.c中的passive_alloc函数中判断，当va小于UTEMP时，调用sys_send_sig发送信号</p>
</li>
<li><p>用户程序进入入口为user&#x2F;lib下的libman函数</p>
<ul>
<li>该函数第一步设置自身进程的信息处理函数，该处理函数被单独封装（形式类似cow_entry）</li>
</ul>
</li>
<li><p>在这个用户态信号处理函数中</p>
<ul>
<li>该函数的三个参数即为do_signal时保存的sp，signum以及处理函数sa_handler</li>
<li>如果sa_handler不为空，则运行信号处理函数，并将处理完的信号从栈中弹出；设置当前进程的现场</li>
<li>否则，如果信息编号为SIG_SEGV或者SIG_KILL或者SIG_TERM，也弹出该信号，结束进程</li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>主要利用实验平台样例和自己构造测试样例来进行测试</p>
<p>构造的测试样例主要包括以下几方面</p>
<ul>
<li>检查注册函数</li>
<li>检查子进程继承父进程处理函数&#x2F;写时复制是否正确</li>
<li>检查信号的注册和发送是否正确</li>
<li>检查sigprocmask是否正确</li>
<li>检查用户态函数sigemptyset、sigfillset、sigaddset、sigdelset、sigismember是否正确</li>
<li>检查空指针异常处理</li>
</ul>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>主要在思考如何跳转到信号处理函数、如何保存上下文、如何实现信号的重入等情况</p>
]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
